<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Ecto Introduction :: Phoenix Beginner&#x27;s Guide</title>
    <link rel="canonical" href="https://www.wintermeyer-consulting.de/books/phoenix/1.5/phoenix/1.5/ecto-basics.html">
    <meta name="generator" content="Antora 2.3.1">
    <link rel="stylesheet" href="../../antora-assets/css/site.css">
    <link rel="stylesheet" href="../../antora-assets/css/site-extra.css">
  </head>
  <body class="article">
<header class="header" role="banner">
  <nav class="navbar">
    <div class="navbar-brand">
      <div class="navbar-item">
        <a href="/">Wintermeyer Consulting</a>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item has-dropdown is-hoverable">
          <div class="navbar-link">Phoenix Links</div>
          <div class="navbar-dropdown">
            <div class="navbar-item"><strong>Phoenix Framework</strong></div>
            <a class="navbar-item" href="https://www.phoenixframework.org">Phoenix Homepage</a>
            <a class="navbar-item" href="https://github.com/phoenixframework/phoenix">GitHub Repository</a>
            <hr class="navbar-divider">
            <div class="navbar-item"><strong>Elixir</strong></div>
            <a class="navbar-item" href="https://elixir-lang.org">Elixir Homepage</a>
            <a class="navbar-item" href="https://github.com/elixir-lang/elixir">GitHub Repository</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <div class="navbar-link">Stefan Wintermeyer</div>
          <div class="navbar-dropdown">
            <div class="navbar-item"><strong>Work related</strong></div>
            <a class="navbar-item" href="https://www.wintermeyer-consulting.de">Training and Consulting</a>
            <a class="navbar-item"
              href="https://speakerdeck.com/wintermeyer">SpeakerDeck</a>
            <hr class="navbar-divider">
            <div class="navbar-item"><strong>Phoenix projects</strong></div>
            <a class="navbar-item"
              href="https://www.vutuv.de/users/stefan.wintermeyer">vutuv</a>
            <a class="navbar-item"
              href="https://www.mehr-schulferien.de">Schulferien Deutschland</a>
            <div class="navbar-item"><strong>Private</strong></div>
            <a class="navbar-item" href="https://www.wintermeyer.de">Personal Homepage</a>
            <div class="navbar-item"><strong>Social Media</strong></div>
            <a class="navbar-item" href="https://twitter.com/wintermeyer">Twitter</a>
            <a class="navbar-item" href="https://www.facebook.com/stefan.wintermeyer">Facebook</a>
            <a class="navbar-item"
              href="https://www.instagram.com/wintermeyer/">Instagram</a>
          </div>
        </div>
        <a class="navbar-item" href="https://twitter.com/wintermeyer">
          <span class="icon">
            <svg aria-hidden="true" data-icon="twitter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
              <path fill="#57aaee" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path>
            </svg>
          </span>
        </a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="phoenix" data-version="1.5">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">Phoenix Beginner&#x27;s Guide</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index.html#preface">Preface</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="elixir-introduction.html">Elixir Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="phoenix-basics.html">Phoenix Basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-basics.html#the-base-setup">The Base Setup</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-basics.html#hello-world">Hello World!</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="phoenix-basics.html#conn-struct">The conn Struct</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="phoenix-basics.html#static-clock">Static Clock</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-basics.html#links">Links</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="phoenix-basics.html#static-files">Static files</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="phoenix-basics.html#images">Images</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-basics.html#css">CSS</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="phoenix-liveview-basics.html">LiveView Basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-liveview-basics.html#light-switch">Light Switch</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-liveview-basics.html#clock">Clock</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-liveview-basics.html#counter">Counter</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-liveview-basics.html#aiport-code-search">Airport Code Search</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-liveview-basics.html#autocomplete">Autocomplete</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="router.html">Router</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="router.html#mix-phx-routes">Display all existing routes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="router.html#router-params">Params</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="router.html#router-query-string">Query Strings</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="router.html#router-multilevel-paths">Multilevel Paths</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="router.html#router-wildcards">Wildcards</a>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="ecto-basics.html">Ecto Basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#ecto-create-database">Create a Database</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#ecto-create-table">Create a Table</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#ecto-create-dataset">Create a Dataset</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#validations">Validations</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#ecto-uniqueness">Uniqueness Validations</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#ecto-seeds">Seeds</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#ecto-query">Querying the Database</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#ecto-update">Update an Entry</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#ecto-associations">Associations</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index.html#remote-training">Remote training for beginners</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Phoenix Beginner&#x27;s Guide</span>
    <span class="version">1.5</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Phoenix Beginner's Guide</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">1.5</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Phoenix Beginner's Guide</a></li>
    <li><a href="ecto-basics.html">Ecto Basics</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="file:///Users/stefan/Github/phoenix-book/modules/ROOT/pages/ecto-basics.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<article class="doc">
<h1 class="page">Ecto Introduction</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Ecto is a persistence framework for Elixir. That is a fancy way of saying that
we use Ecto to talk to a SQL database. This chapter will introduce you to the
very basics of Ecto in the Phoenix context. This means that whenever available,
we use functions that were created by Phoenix generators.</p>
</div>
<div class="paragraph">
<p>You&#8217;ll learn:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>How to create a database and a table.</p>
</li>
<li>
<p>How to insert data into that table.</p>
</li>
<li>
<p>How to list all data from that table.</p>
</li>
<li>
<p>How to get a dataset from that table by its ID.</p>
</li>
<li>
<p>How to update a dataset.</p>
</li>
<li>
<p>How to delete a dataset.</p>
</li>
<li>
<p>Basic search queries.</p>
</li>
<li>
<p>Basic associations (e.g. one-to-many)</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We are going to use a <a href="https://www.postgresql.org">PostgreSQL</a> database. Ecto
works fine with other databases too (e.g. <a href="https://mariadb.com">MariaDB</a>), but most
Phoenix developers prefer PostgreSQL. For this book, we assume that you have a
PostgreSQL user on your development system with the right to create a database
and the following credentials:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>user: postgres</p>
</li>
<li>
<p>password: postgres</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These are the default values for the development system in Phoenix.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Ecto is a vast topic. In one chapter, I can only scratch its
surface. If you want to dive into it more in-depth, you should read the book
<a href="https://pragprog.com/book/wmecto/programming-ecto">Programming Ecto</a> by
<a href="https://twitter.com/darinwilson">Darin Wilson</a>. Also
<a href="https://www.youtube.com/results?search_query=Darin+Wilson+Ecto+Elixir">search for Darin&#8217;s Ecto talks on YouTube</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ecto-create-database"><a class="anchor" href="#ecto-create-database"></a>Create a Database</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before we can do anything, we have to create a database. Let&#8217;s create a small
bookstore database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix phx.new bookstore
[...]
$ cd bookstore
$ mix ecto.create
Compiling 14 files (.ex)
Generated bookstore app
The database for Bookstore.Repo has been created</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
In case you want to drop this database (e.g. to rerun the <code>mix
ecto.create</code> command) you can do so with the command <code>mix ecto.drop</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The configuration for this development database can be found in the file
<code>config/dev.exs</code>. Please make changes to that file if you use a different
database or user.</p>
</div>
<div class="listingblock">
<div class="title">config/dev.exs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">use Mix.Config

# Configure your database
config :bookstore, Bookstore.Repo,
  username: "postgres",
  password: "postgres",
  database: "bookstore_dev",
  hostname: "localhost",
  show_sensitive_data_on_connection_error: true,
  pool_size: 10
[...]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ecto-create-table"><a class="anchor" href="#ecto-create-table"></a>Create a Table</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For this example, we are going to use the <code>mix phx.gen.context</code>
generator(<a href="https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.Context.html" class="bare">https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.Context.html</a>), which
creates a database table and adds files that are useful for working with the
new table.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can do everything a generator does manually, but it is faster and
results in fewer errors if you use a generator.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As a first resource, we want to create a table with authors. In the Phoenix
world, we have to put that new resource <code>authors</code> into a context.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A context(<a href="https://hexdocs.pm/phoenix/contexts.html" class="bare">https://hexdocs.pm/phoenix/contexts.html</a>) is an API boundary for
one or more resources. Since version 1.3 of Phoenix, it has been recommended to
organize the code that interfaces with the database using contexts, as this can
help make the code easier to test, maintain and refactor. At this stage, don&#8217;t
worry if you find the idea of contexts difficult to understand. You will soon
get a feel for them as you work through the examples.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix phx.gen.context Store Author authors first_name last_name twitter_account
* creating lib/bookstore/store/author.ex
* creating priv/repo/migrations/20200526112425_create_authors.exs
* creating lib/bookstore/store.ex
* injecting lib/bookstore/store.ex
* creating test/bookstore/store_test.exs
* injecting test/bookstore/store_test.exs

Remember to update your repository by running migrations:

    $ mix ecto.migrate</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="ecto-migrations"><a class="anchor" href="#ecto-migrations"></a>Migrations</h3>
<div class="paragraph">
<p>Migrations are used to keep track of the process of generating or changing your
database. This makes it a lot easier to keep all the databases, of other
developers in your team, the production server, etc., synchronized.</p>
</div>
<div class="paragraph">
<p>The generated migration is stored in the file <code>priv/repo/migrations/20200526112425_create_authors.exs</code>. What it does is pretty clear once you have a look into it:</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Migration filenames include a timestamp. It is better not to copy and
paste the migration filenames as you work through this chapter.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">priv/repo/migrations/20200526112425_create_authors.exs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule Bookstore.Repo.Migrations.CreateAuthors do
  use Ecto.Migration

  def change do
    create table(:authors) do
      add :first_name, :string
      add :last_name, :string
      add :twitter_account, :string

      timestamps() <i class="conum" data-value="1"></i><b>(1)</b>
    end

  end
end</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>timestamps()</code> generates the fields <code>updated_at</code> and <code>inserted_at</code>. Both are
updated with the current timestamp during the creation of a dataset. Afterwards,
only <code>updated_at</code> is updated with the current timestamp whenever Ecto changes
that dataset.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To run the migration, we call <code>mix ecto.migrate</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix ecto.migrate
Compiling 2 files (.ex)
Generated bookstore app

13:30:35.437 [info]  == Running 20200526112425 Bookstore.Repo.Migrations.CreateAuthors.change/0 forward

13:30:35.440 [info]  create table authors

13:30:35.458 [info]  == Migrated 20200526112425 in 0.0s</code></pre>
</div>
</div>
<div class="paragraph">
<p>According to this output, the <code>authors</code> table was created in the <code>bookstore_dev</code>
database. But let&#8217;s double check:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ psql -U postgres bookstore_dev <i class="conum" data-value="1"></i><b>(1)</b>
psql (12.2)
Type "help" for help.

bookstore_dev=# SELECT column_name FROM information_schema.columns WHERE TABLE_NAME='authors'; <i class="conum" data-value="2"></i><b>(2)</b>
   column_name
-----------------
 id
 first_name
 last_name
 twitter_account
 inserted_at
 updated_at
(6 rows)

bookstore_dev=# \q <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>psql</code> is the command-line client for PostgreSQL. If you are not familiar with it: Don&#8217;t try this at home!</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This command lists all column names of the table <code>authors</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>\q</code> is the command to quit the PostgreSQL command-line client.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We can see that the migration created the <code>authors</code> table and added the columns.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can undo a migration with a rollback:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix ecto.rollback

12:48:54.388 [info]  == Running 20200526112425 Bookstore.Repo.Migrations.CreateAuthors.change/0 backward

12:48:54.390 [info]  drop table authors

12:48:54.398 [info]  == Migrated 20200526112425 in 0.0s</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you test the rollback now, you will have to run the migration again
afterwards.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>phx.gen.context</code> generated, in addition to the migration file, the schema in
<code>lib/bookstore/store/author.ex</code> and the context module in
<code>lib/bookstore/store.ex</code>. We&#8217;ll look at both of these files in the next section.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ecto-create-dataset"><a class="anchor" href="#ecto-create-dataset"></a>Create a Dataset</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We have a database and a table. But we still need to create our first set of
data. To do that, we have to open <code>iex</code>. Within a Phoenix project, we can do
this with the command <code>iex -S mix phx.server</code>. It loads the whole Phoenix
project. It starts the webserver too (you see it sorting out the assets
during startup) but right now we only use <code>iex</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ iex -S mix phx.server
Erlang/OTP 22 [erts-10.6.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

[info] Running BookstoreWeb.Endpoint with cowboy 2.7.0 at 0.0.0.0:4000 (http)
[info] Access BookstoreWeb.Endpoint at http://localhost:4000
Interactive Elixir (1.10.2) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&gt; <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Actually you will see a couple of more messages here which are related to
the assets pipeline (e.g. CSS and JavaScript). No need to bother with those now.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The context module in <code>lib/bookstore/store.ex</code> includes the <code>create_author/1</code>
function which we use to create a new author:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(2)&gt; Bookstore.Store.create_author(%{first_name: "Dave", last_name: "Thomas", twitter_account: "pragdave"})
[debug] QUERY OK db=3.8ms decode=1.5ms queue=2.5ms idle=1355.7ms
INSERT INTO "authors" ("first_name","last_name","twitter_account","inserted_at","updated_at") VALUES ($1,$2,$3,$4,$5) RETURNING "id" ["Dave", "Thomas", "pragdave", ~N[2020-05-26 11:54:37], ~N[2020-05-26 11:54:37]]
{:ok,
 %Bookstore.Store.Author{
   __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
   first_name: "Dave",
   id: 1,
   inserted_at: ~N[2020-05-26 11:54:37],
   last_name: "Thomas",
   twitter_account: "pragdave",
   updated_at: ~N[2020-05-26 11:54:37]
 }}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use <code>alias Bookstore.Store</code> at the beginning of an <code>iex</code> session and
afterwards <code>Store.create_author()</code> to save typing time. This can make the code
easier to read.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you are wondering what <code>create_author/1</code> does, look at the
<code>lib/bookstore/store.ex</code> file:</p>
</div>
<div class="listingblock">
<div class="title">lib/bookstore/store.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">[...]
alias Bookstore.Repo
alias Bookstore.Store.Author
[...]
def create_author(attrs \\ %{}) do
  %Author{}
  |&gt; Author.changeset(attrs) <i class="conum" data-value="1"></i><b>(1)</b>
  |&gt; Repo.insert() <i class="conum" data-value="2"></i><b>(2)</b>
end
[...]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creates a new Author changeset with the attributes.
Changesets(<a href="https://hexdocs.pm/ecto/Ecto.Changeset.html" class="bare">https://hexdocs.pm/ecto/Ecto.Changeset.html</a>) are structs that can be
used to filter, cast and validate the data.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Uses <code>Bookstore.Repo</code> to insert the changeset into the database table.</td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the insert in the table was successful, the function returns a
<code>{:ok, %Bookstore.Store.Author{}}</code> tuple.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Assuming you&#8217;d like to assign the new author to the variable <code>author</code>. How would
you do that? <code>create_author/1</code> returns a tuple and not an Author. Pattern
matching to the rescue! Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(2)&gt; {:ok, author} = Bookstore.Store.create_author(%{first_name: "Dave", last_name: "Thomas", twitter_account: "pragdave"})
[debug] QUERY OK db=3.4ms decode=1.5ms queue=1.3ms idle=1013.5ms
INSERT INTO "authors" ("first_name","last_name","twitter_account","inserted_at","updated_at") VALUES ($1,$2,$3,$4,$5) RETURNING "id" ["Dave", "Thomas", "pragdave", ~N[2020-05-27 11:00:19], ~N[2020-05-27 11:00:19]]
{:ok,
 %Bookstore.Store.Author{
   __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
   first_name: "Dave",
   id: 1,
   inserted_at: ~N[2020-05-27 11:00:19],
   last_name: "Thomas",
   twitter_account: "pragdave",
   updated_at: ~N[2020-05-27 11:00:19]
 }}
iex(3)&gt; author
%Bookstore.Store.Author{
  __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
  first_name: "Dave",
  id: 1,
  inserted_at: ~N[2020-05-27 11:00:19],
  last_name: "Thomas",
  twitter_account: "pragdave",
  updated_at: ~N[2020-05-27 11:00:19]
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ecto-validations"><a class="anchor" href="#ecto-validations"></a>Validations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If we try to create an empty dataset this happens:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(3)&gt; Bookstore.Store.create_author(%{})
{:error,
 #Ecto.Changeset&lt;
   action: :insert,
   changes: %{},
   errors: [
     first_name: {"can't be blank", [validation: :required]},
     last_name: {"can't be blank", [validation: :required]},
     twitter_account: {"can't be blank", [validation: :required]}
   ],
   data: #Bookstore.Store.Author&lt;&gt;,
   valid?: false
 &gt;}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>create_author/1</code> function returns a <code>{:error, #Ecto.Changeset &#8230;&#8203;}</code> tuple
and it lists the reasons in the <code>errors</code> list:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>first_name: {"can&#8217;t be blank", [validation: :required]}</code></p>
</li>
<li>
<p><code>last_name: {"can&#8217;t be blank", [validation: :required]}</code></p>
</li>
<li>
<p><code>twitter_account: {"can&#8217;t be blank", [validation: :required]}</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It seems that some sort of data validation is happening. To understand how this
works, we have to look at the <code>lib/bookstore/store/author.ex</code> file.</p>
</div>
<div class="listingblock">
<div class="title">lib/bookstore/store/author.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule Bookstore.Store.Author do
  use Ecto.Schema
  import Ecto.Changeset

  schema "authors" do <i class="conum" data-value="1"></i><b>(1)</b>
    field :first_name, :string
    field :last_name, :string
    field :twitter_account, :string

    timestamps()
  end

  @doc false
  def changeset(author, attrs) do
    author
    |&gt; cast(attrs, [:first_name, :last_name, :twitter_account]) <i class="conum" data-value="2"></i><b>(2)</b>
    |&gt; validate_required([:first_name, :last_name, :twitter_account]) <i class="conum" data-value="3"></i><b>(3)</b>
  end
end</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is the schema of the <code>authors</code> model.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><a href="https://hexdocs.pm/ecto/Ecto.Changeset.html#cast/4">cast/4</a> casts the input.
Only fields which are listed in the list can make it through. Everything else is
thrown away right here.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Here&#8217;s the reason why <code>Bookstore.Store.create_author(%{})</code> resulted in an
error. The function
<a href="https://hexdocs.pm/ecto/Ecto.Changeset.html#validate_required/3">validate_required/3</a>
checks whether all the list items are included.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Changesets are the gatekeepers of Ecto. In the next example, let&#8217;s add some more
validations to our author changeset:</p>
</div>
<div class="listingblock">
<div class="title">lib/bookstore/store/author.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">[...]
  def changeset(author, attrs) do
    author
    |&gt; cast(attrs, [:first_name, :last_name, :twitter_account])
    |&gt; validate_required([:last_name]) <i class="conum" data-value="1"></i><b>(1)</b>
    |&gt; validate_length(:first_name, max: 255) <i class="conum" data-value="2"></i><b>(2)</b>
    |&gt; validate_length(:last_name, max: 255) <i class="conum" data-value="3"></i><b>(3)</b>
    |&gt; validate_length(:twitter_account, max: 15) <i class="conum" data-value="4"></i><b>(4)</b>
  end
[...]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We make sure that a dataset has a <code>last_name</code>. But it doesn&#8217;t have to have a <code>first_name</code> or a <code>twitter_account</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If a <code>first_name</code> is used, it can not be longer than 255 characters.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A <code>last_name</code> can not be longer than 255 characters.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>If a <code>twitter_account</code> is used, it can not be longer than 15 characters (the max limit for Twitter handles).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we get a different error message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elxir hljs" data-lang="elxir">iex(4)&gt; Bookstore.Store.create_author(%{})
{:error,
 #Ecto.Changeset&lt;
   action: :insert,
   changes: %{},
   errors: [last_name: {"can't be blank", [validation: :required]}],
   data: #Bookstore.Store.Author&lt;&gt;,
   valid?: false
 &gt;}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But let&#8217;s try to add an author with a missing <code>first_name</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elxir hljs" data-lang="elxir">iex(6)&gt; Bookstore.Store.create_author(%{last_name: "Thomas", twitter_account: "pragdave"})
[debug] QUERY OK db=1.0ms queue=0.5ms idle=1349.0ms
INSERT INTO "authors" ("last_name","twitter_account","inserted_at","updated_at") VALUES ($1,$2,$3,$4) RETURNING "id" ["Thomas", "pragdave", ~N[2020-05-27 05:37:46], ~N[2020-05-27 05:37:46]]
{:ok,
 %Bookstore.Store.Author{
   __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
   first_name: nil,
   id: 3,
   inserted_at: ~N[2020-05-27 05:37:46],
   last_name: "Thomas",
   twitter_account: "pragdave",
   updated_at: ~N[2020-05-27 05:37:46]
 }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>No surprise here. It works.</p>
</div>
<div class="paragraph">
<p>A list of available validations can be found at <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html" class="bare">https://hexdocs.pm/ecto/Ecto.Changeset.html</a></p>
</div>
<div class="sect2">
<h3 id="ecto-uniqueness"><a class="anchor" href="#ecto-uniqueness"></a>Uniqueness Validation</h3>
<div class="paragraph">
<p>In the last section, we created two datasets with the same Twitter account. That
shouldn&#8217;t happen because it is unique. We have to add a validation for that.</p>
</div>
<div class="paragraph">
<p>A uniqueness validation needs a uniqueness database index. Since we haven&#8217;t
added an index during the creation of the <code>authors</code> table, we have to add a
migration to do it now.</p>
</div>
<div class="paragraph">
<p>To add a migration, we first need to create a migration file using the <code>mix
ecto.gen.migration</code> command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix ecto.gen.migration add_twitter_account_index
Compiling 1 file (.ex)
* creating priv/repo/migrations/20200527054827_add_twitter_account_index.exs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we have to edit the generated file, adding a function to create a unique
index:</p>
</div>
<div class="listingblock">
<div class="title">priv/repo/migrations/20200527054827_add_twitter_account_index.exs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule Bookstore.Repo.Migrations.AddTwitterAccountIndex do
  use Ecto.Migration

  def change do
    create unique_index(:authors, [:twitter_account])
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>And finally, we need to run the migration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix ecto.migrate

07:55:14.846 [info]  == Running 20200527054827 Bookstore.Repo.Migrations.AddTwitterAccountIndex.change/0 forward

07:55:14.849 [info]  create index authors_twitter_account_index
** (Postgrex.Error) ERROR 23505 (unique_violation) could not create unique index "authors_twitter_account_index"

    table: authors
    constraint: authors_twitter_account_index

Key (twitter_account)=(pragdave) is duplicated.
[...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Oops! Because we have two entries with the same <code>twitter_account</code> the unique
index can not be created. We can solve this in the following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Delete one entry in the table and rerun the migration.</p>
</li>
<li>
<p>Do a <code>mix ecto.drop</code>, <code>mix ecto.create</code> and <code>mix ecto.migrate</code>. That destroys
the existing data. Since this is a development system, there is little harm in
doing this.</p>
</li>
<li>
<p>Do a <code>mix ecto.reset</code>, which is an alias (defined in the <code>mix.exs</code> file) for
the above set of commands. It also populates the database with seeds if you
have them. We don&#8217;t have any seeds yet.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We will use the alias <code>mix ecto.reset</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix ecto.reset
The database for Bookstore.Repo has been dropped <i class="conum" data-value="1"></i><b>(1)</b>
The database for Bookstore.Repo has been created <i class="conum" data-value="2"></i><b>(2)</b>

08:02:33.469 [info]  == Running 20200526112425 Bookstore.Repo.Migrations.CreateAuthors.change/0 forward

08:02:33.471 [info]  create table authors

08:02:33.481 [info]  == Migrated 20200526112425 in 0.0s <i class="conum" data-value="3"></i><b>(3)</b>

08:02:33.540 [info]  == Running 20200527054827 Bookstore.Repo.Migrations.AddTwitterAccountIndex.change/0 forward

08:02:33.541 [info]  create index authors_twitter_account_index

08:02:33.543 [info]  == Migrated 20200527054827 in 0.0s <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>mix ecto.drop</code> drops the database.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>mix ecto.create</code> creates a new database.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Runs the first migration. The one with 20200526112425 in it&#8217;s filename.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Runs the second migration. The one with 20200527054827 in it&#8217;s filename. This one creates the index.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The uniqueness index in the table does make sure that we can&#8217;t add a second
author with the same Twitter account to the table, but this constraint violation
raises an exception. This is better than nothing, but not what we want. We
want an error added to our changeset, and so we have to add one more line to the
changeset:</p>
</div>
<div class="listingblock">
<div class="title">lib/bookstore/store/author.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">[...]
  def changeset(author, attrs) do
    author
    |&gt; cast(attrs, [:first_name, :last_name, :twitter_account])
    |&gt; validate_required([:last_name])
    |&gt; validate_length(:first_name, max: 255)
    |&gt; validate_length(:last_name, max: 255)
    |&gt; validate_length(:twitter_account, max: 15)
    |&gt; unique_constraint(:twitter_account) <i class="conum" data-value="1"></i><b>(1)</b>
  end
[...]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html#unique_constraint/3">unique_constrain/3</a> validation which will add an error to our changeset.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Time to check our work. Please fire up <code>iex -S mix phx.server</code> and follow me:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">$ iex -S mix phx.server
[...]
iex(1)&gt; Bookstore.Store.create_author(%{first_name: "Dave", last_name: "Thomas", twitter_account: "pragdave"})
[debug] QUERY OK db=3.0ms decode=1.4ms queue=1.4ms idle=1965.4ms
INSERT INTO "authors" ("first_name","last_name","twitter_account","inserted_at","updated_at") VALUES ($1,$2,$3,$4,$5) RETURNING "id" ["Dave", "Thomas", "pragdave", ~N[2020-05-27 06:17:18], ~N[2020-05-27 06:17:18]]
{:ok,
 %Bookstore.Store.Author{
   __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
   first_name: "Dave",
   id: 1,
   inserted_at: ~N[2020-05-27 06:17:18],
   last_name: "Thomas",
   twitter_account: "pragdave",
   updated_at: ~N[2020-05-27 06:17:18]
 }} <i class="conum" data-value="1"></i><b>(1)</b>
iex(2)&gt; Bookstore.Store.create_author(%{first_name: "Dave", last_name: "Thomas", twitter_account: "pragdave"})
[debug] QUERY ERROR db=8.1ms queue=2.3ms idle=1590.4ms
INSERT INTO "authors" ("first_name","last_name","twitter_account","inserted_at","updated_at") VALUES ($1,$2,$3,$4,$5) RETURNING "id" ["Dave", "Thomas", "pragdave", ~N[2020-05-27 06:17:20], ~N[2020-05-27 06:17:20]]
{:error,
 #Ecto.Changeset&lt;
   action: :insert,
   changes: %{
     first_name: "Dave",
     last_name: "Thomas",
     twitter_account: "pragdave"
   },
   errors: [
     twitter_account: {"has already been taken",
      [constraint: :unique, constraint_name: "authors_twitter_account_index"]}
   ],
   data: #Bookstore.Store.Author&lt;&gt;,
   valid?: false
 &gt;} <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Works nicely. It results in a <code>{:ok, %Bookstore.Store.Author()}</code> which tells
us that the dataset is saved.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Works too. The second attempt to create an entry with the same data results
in <code>{:error, #Ecto.Changeset}</code>. The <code>errors</code> tell us that <code>twitter_account:
{"has already been taken", [constraint: :unique, constraint_name:
"authors_twitter_account_index"]}</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_uniqueness_over_multiple_fields"><a class="anchor" href="#_uniqueness_over_multiple_fields"></a>Uniqueness over multiple fields</h3>
<div class="paragraph">
<p>Sometimes you need to assure a uniqueness not just over one but over multiple
fields. To show how this is done, I assume that our <code>authors</code> table should not
contain two authors with the same full name (e.g. no two <code>Dave Thomas</code> or
<code>Stefan Wintermeyer</code>). To achieve that we have to check <code>first_name</code> and
<code>last_name</code> in combination. We have to do that in the database with a combined
index.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix ecto.gen.migration add_full_name_index
* creating priv/repo/migrations/20200527071855_add_full_name_index.exs</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">priv/repo/migrations/20200527071855_add_full_name_index.exs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule Bookstore.Repo.Migrations.AddFullNameIndex do
  use Ecto.Migration

  def change do
    create unique_index(:authors, [:first_name, :last_name]) <i class="conum" data-value="1"></i><b>(1)</b>
  end
end</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creates a concatenated index of the fields <code>first_name</code> and <code>last_name</code>.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">lib/bookstore/store/author.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">[...]
  def changeset(author, attrs) do
    author
    |&gt; cast(attrs, [:first_name, :last_name, :twitter_account])
    |&gt; validate_required([:last_name])
    |&gt; validate_length(:first_name, max: 255)
    |&gt; validate_length(:last_name, max: 255)
    |&gt; validate_length(:twitter_account, max: 15)
    |&gt; unique_constraint(:twitter_account)
    |&gt; unique_constraint([:first_name, :last_name]) <i class="conum" data-value="1"></i><b>(1)</b>
  end
[...]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This <code>unique_constraint/1</code> will trigger an error message instead of raising
an exception.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">$ mix ecto.reset <i class="conum" data-value="1"></i><b>(1)</b>
Compiling 1 file (.ex)
The database for Bookstore.Repo has been dropped
The database for Bookstore.Repo has been created.
[...]
09:45:21.380 [info]  create index authors_first_name_last_name_index

09:45:21.382 [info]  == Migrated 20200527071855 in 0.0s

$ iex -S mix phx.server
[...]
iex(1)&gt; alias Bookstore.Store <i class="conum" data-value="2"></i><b>(2)</b>
Bookstore.Store
iex(2)&gt; Store.create_author(%{first_name: "Dave", last_name: "Thomas"}) <i class="conum" data-value="3"></i><b>(3)</b>
[debug] QUERY OK db=5.2ms decode=2.6ms queue=1.5ms idle=1377.6ms
INSERT INTO "authors" ("first_name","last_name","inserted_at","updated_at") VALUES ($1,$2,$3,$4) RETURNING "id" ["Dave", "Thomas", ~N[2020-05-27 08:35:29], ~N[2020-05-27 08:35:29]]
{:ok,
 %Bookstore.Store.Author{
   __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
   first_name: "Dave",
   id: 1,
   inserted_at: ~N[2020-05-27 08:35:29],
   last_name: "Thomas",
   twitter_account: nil,
   updated_at: ~N[2020-05-27 08:35:29]
 }}
iex(3)&gt; Store.create_author(%{first_name: "Dave", last_name: "Thomas"}) <i class="conum" data-value="4"></i><b>(4)</b>
[debug] QUERY ERROR db=9.1ms queue=1.3ms idle=1548.4ms
INSERT INTO "authors" ("first_name","last_name","inserted_at","updated_at") VALUES ($1,$2,$3,$4) RETURNING "id" ["Dave", "Thomas", ~N[2020-05-27 08:35:31], ~N[2020-05-27 08:35:31]]
{:error,
 #Ecto.Changeset&lt;
   action: :insert,
   changes: %{first_name: "Dave", last_name: "Thomas"},
   errors: [
     first_name: {"has already been taken",
      [
        constraint: :unique,
        constraint_name: "authors_first_name_last_name_index"
      ]}
   ],
   data: #Bookstore.Store.Author&lt;&gt;,
   valid?: false
 &gt;}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Resets our database.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Sets a <code>Bookstore.Store</code> alias to saves us some precious time to type the command.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The first Dave Thomas is created.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>A second Dave Thomas can not be created.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In the example above, the error message says that the <code>:first_name</code> has been
taken, but, strictly speaking, this is not correct because the constraint is for
the <code>:first_name</code> and <code>:last_name</code> together. Below is a slightly different
approach, where a more descriptive name is set for the index.</p>
</div>
<div class="listingblock">
<div class="title">priv/repo/migrations/20200527071855_add_full_name_index.exs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule Bookstore.Repo.Migrations.AddFullNameIndex do
  use Ecto.Migration

  def change do
    create unique_index(:authors, [:first_name, :last_name], name: :full_name) <i class="conum" data-value="1"></i><b>(1)</b>
  end
end</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We tell Ecto which name the index should have.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">lib/bookstore/store/author.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">[...]
  def changeset(author, attrs) do
    author
    |&gt; cast(attrs, [:first_name, :last_name, :twitter_account])
    |&gt; validate_required([:last_name])
    |&gt; validate_length(:first_name, max: 255)
    |&gt; validate_length(:last_name, max: 255)
    |&gt; validate_length(:twitter_account, max: 15)
    |&gt; unique_constraint(:twitter_account)
    |&gt; unique_constraint(:full_name, name: :full_name) <i class="conum" data-value="1"></i><b>(1)</b>
  end
[...]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The unique_constraint uses <code>:full_name</code>.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(3)&gt; Bookstore.Store.create_author(%{first_name: "Dave", last_name: "Thomas"})
[debug] QUERY ERROR db=2.1ms queue=0.7ms idle=1.5e3ms
INSERT INTO "authors" ("first_name","last_name","inserted_at","updated_at") VALUES ($1,$2,$3,$4) RETURNING "id" ["Dave", "Thomas", ~N[2020-05-27 11:19:42], ~N[2020-05-27 11:19:42]]
{:error,
 #Ecto.Changeset&lt;
   action: :insert,
   changes: %{first_name: "Dave", last_name: "Thomas"},
   errors: [
     full_name: {"has already been taken",
      [constraint: :unique, constraint_name: "full_name"]} <i class="conum" data-value="1"></i><b>(1)</b>
   ],
   data: #Bookstore.Store.Author&lt;&gt;,
   valid?: false
 &gt;}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We get an error for <code>full_name</code>.</td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ecto-seeds"><a class="anchor" href="#ecto-seeds"></a>Seeds</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Often you need the database prefilled with data for your application. That&#8217;s
what seeds are for. By default, they are in the <code>priv/repo/seeds.exs</code> file. For
our bookstore we can work with these seeds:</p>
</div>
<div class="listingblock">
<div class="title">priv/repo/seeds.exs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">alias Bookstore.Store

Store.create_author(%{
  first_name: "Dave",
  last_name: "Thomas",
  twitter_account: "pragdave"
})
Store.create_author(%{
  first_name: "James",
  last_name: "Gray",
  twitter_account: "jeg2"
})
Store.create_author(%{
  first_name: "Ulisses",
  last_name: "Almeida",
  twitter_account: "ulissesalmeida"
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>To populate the database we call <code>mix run priv/repo/seeds.exs</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">$ mix run priv/repo/seeds.exs
[debug] QUERY ERROR db=11.1ms queue=1.1ms idle=5.3ms
INSERT INTO "authors" ("first_name","last_name","twitter_account","inserted_at","updated_at") VALUES ($1,$2,$3,$4,$5) RETURNING "id" ["Dave", "Thomas", "pragdave", ~N[2020-05-27 11:47:40], ~N[2020-05-27 11:47:40]]
[debug] QUERY OK db=1.9ms queue=1.4ms idle=36.1ms
INSERT INTO "authors" ("first_name","last_name","twitter_account","inserted_at","updated_at") VALUES ($1,$2,$3,$4,$5) RETURNING "id" ["James", "Gray", "jeg2", ~N[2020-05-27 11:47:40], ~N[2020-05-27 11:47:40]]
[debug] QUERY OK db=1.0ms queue=0.7ms idle=39.8ms
INSERT INTO "authors" ("first_name","last_name","twitter_account","inserted_at","updated_at") VALUES ($1,$2,$3,$4,$5) RETURNING "id" ["Ulisses", "Almeida", "ulissesalmeida", ~N[2020-05-27 11:47:40], ~N[2020-05-27 11:47:40]]</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
During development, the command <code>mix ecto.reset</code> is often very useful. It
resets the database (drops, creates and migrates the database) and runs the
seeds.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ecto-query"><a class="anchor" href="#ecto-query"></a>Querying the Database</h2>
<div class="sectionbody">
<div class="paragraph">
<p>After adding data to the database table, we now want to be able to fetch any
data that we need.</p>
</div>
<div class="paragraph">
<p>In this section, we will look at fetching all of a table&#8217;s entries, fetching a
single entry using the ID (primary key) and fetching a single entry using one
or more attributes.</p>
</div>
<div class="sect2">
<h3 id="ecto-list"><a class="anchor" href="#ecto-list"></a>Return all of a Table&#8217;s Entries</h3>
<div class="paragraph">
<p>The generated <code>Bookstore.Store</code> module offers a <code>list_authors/0</code> function which
simply returns a list of all authors in the table:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">$ iex -S mix phx.server
[...]
iex(2)&gt; Bookstore.Store.list_authors
[debug] QUERY OK source="authors" db=11.5ms decode=1.3ms queue=1.2ms idle=889.7ms
SELECT a0."id", a0."first_name", a0."last_name", a0."twitter_account", a0."inserted_at", a0."updated_at" FROM "authors" AS a0 []
[
  %Bookstore.Store.Author{
    __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
    first_name: "Dave",
    id: 1,
    inserted_at: ~N[2020-05-27 11:48:17],
    last_name: "Thomas",
    twitter_account: "pragdave",
    updated_at: ~N[2020-05-27 11:48:17]
  },
  %Bookstore.Store.Author{
    __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
    first_name: "James",
    id: 2,
    inserted_at: ~N[2020-05-27 11:48:17],
    last_name: "Gray",
    twitter_account: "jeg2",
    updated_at: ~N[2020-05-27 11:48:17]
  },
  %Bookstore.Store.Author{
    __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
    first_name: "Ulisses",
    id: 3,
    inserted_at: ~N[2020-05-27 11:48:17],
    last_name: "Almeida",
    twitter_account: "ulissesalmeida",
    updated_at: ~N[2020-05-27 11:48:17]
  }
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we look at the code for <code>list_authors/0</code>, we can see that it uses Ecto&#8217;s
<code>Repo.all/1</code> to fetch the data:</p>
</div>
<div class="listingblock">
<div class="title">lib/bookstore/store.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule Bookstore.Store do
[...]
  alias Bookstore.Repo
  alias Bookstore.Store.Author

[...]
  def list_authors do
    Repo.all(Author) <i class="conum" data-value="1"></i><b>(1)</b>
  end
[...]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Repo.all/1</code> requires one argument, which should be a 'queryable' data
structure (at this stage, there&#8217;s no need to worry about what 'queryable'
means). In this case, it is the name of the module where the schema is defined.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As <code>list_authors/0</code> returns a list, we can use pattern matching to get item(s)
from the output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; authors = Bookstore.Store.list_authors
[...]
iex(2)&gt; [first_author | _] = authors <i class="conum" data-value="1"></i><b>(1)</b>
[...]
iex(3)&gt; first_author
%Bookstore.Store.Author{
  __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
  first_name: "Dave",
  id: 1,
  inserted_at: ~N[2020-09-04 02:40:21],
  last_name: "Thomas",
  twitter_account: "pragdave",
  updated_at: ~N[2020-09-04 02:40:21]
}
iex(4)&gt; [first_author, second_author | _] = authors <i class="conum" data-value="2"></i><b>(2)</b>
[...]
iex(5)&gt; second_author
%Bookstore.Store.Author{
  __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
  first_name: "James",
  id: 2,
  inserted_at: ~N[2020-09-04 02:40:21],
  last_name: "Gray",
  twitter_account: "jeg2",
  updated_at: ~N[2020-09-04 02:40:21]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>With pattern matching we take the first item of the list (the head) and
assign it to <code>first_author</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>And on this line, we can get the second item of the list and assign it to
<code>second_author</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ecto-get"><a class="anchor" href="#ecto-get"></a>Fetch Entries by ID</h3>
<div class="paragraph">
<p>If you know the <code>id</code> of a dataset and you want to fetch it, use <code>get_author!/1</code>,
which is in the <code>Bookstore.Store</code> module. Let me first show you how to use it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(2)&gt; Bookstore.Store.get_author!(1)
[debug] QUERY OK source="authors" db=16.1ms decode=1.5ms queue=6.3ms idle=1543.4ms
SELECT a0."id", a0."first_name", a0."last_name", a0."twitter_account", a0."inserted_at", a0."updated_at" FROM "authors" AS a0 WHERE (a0."id" = $1) [1]
%Bookstore.Store.Author{
  __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
  first_name: "Dave",
  id: 1,
  inserted_at: ~N[2020-05-27 11:48:17],
  last_name: "Thomas",
  twitter_account: "pragdave",
  updated_at: ~N[2020-05-27 11:48:17]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And let&#8217;s look at the code for <code>get_author!/1</code>. Here, we see that it uses
Ecto&#8217;s <code>Repo.get!/2</code> to fetch the single entry:</p>
</div>
<div class="listingblock">
<div class="title">lib/bookstore/store.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">[...]
  def get_author!(id), do: Repo.get!(Author, id) <i class="conum" data-value="1"></i><b>(1)</b>
[...]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The second argument for <code>Repo.get!</code> is the entry&#8217;s ID.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>[IMPORTANT] ==== Functions which end with a <code>!</code> (exclamation point) raise an
exception if something goes wrong. Let me show you this with <code>get/2</code> and
<code>get!/2</code> for an <code>id</code> we don&#8217;t have in our table:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(5)&gt; Repo.get(Author, 10000) <i class="conum" data-value="1"></i><b>(1)</b>
nil
[debug] QUERY OK source="authors" db=3.7ms idle=132.4ms
SELECT a0."id", a0."first_name", a0."last_name", a0."twitter_account", a0."inserted_at", a0."updated_at" FROM "authors" AS a0 WHERE (a0."id" = $1) [10000]
iex(6)&gt; Repo.get!(Author, 10000) <i class="conum" data-value="2"></i><b>(2)</b>
[debug] QUERY OK source="authors" db=3.6ms idle=1004.2ms
SELECT a0."id", a0."first_name", a0."last_name", a0."twitter_account", a0."inserted_at", a0."updated_at" FROM "authors" AS a0 WHERE (a0."id" = $1) [10000]
** (Ecto.NoResultsError) expected at least one result but got none in query:

from a0 in Bookstore.Store.Author,
  where: a0.id == ^10000

    (ecto 3.4.4) lib/ecto/repo/queryable.ex:122: Ecto.Repo.Queryable.one!/3</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The ID 10000 doesn&#8217;t exist in the table, and the function returns <code>nil</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The requested ID doesn&#8217;t exist, and the function raises an exception. In
your Phoenix application, if this happens in a function called by a controller,
phoenix will automatically display a 404 page (this functionality depends on
<code>phoenix_ecto</code>, which is included in this example app).</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ecto-get-by"><a class="anchor" href="#ecto-get-by"></a>Fetch Entries by Attribute</h3>
<div class="paragraph">
<p>There are many times when we want to fetch an entry using one or more of the
entry&#8217;s attributes. One way of doing this is to use the <code>Repo.get_by!/2</code>
function.</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s create a function to fetch an entry using the author&#8217;s
twitter account name:</p>
</div>
<div class="listingblock">
<div class="title">lib/bookstore/store.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">[...]
  def get_author_by_twitter!(twitter_account) do <i class="conum" data-value="1"></i><b>(1)</b>
    Repo.get_by!(Author, twitter_account: twitter_account) <i class="conum" data-value="2"></i><b>(2)</b>
  end
[...]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We have added a <code>!</code> to the end of this function (as it is using
<code>Repo.get_by!</code>) to make it clear that it will raise an exception if no results
are found. As mentioned earlier, if this happens, Phoenix will handle the
exception and render a 404 page.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The second argument for <code>Repo.get_by!</code> should be a keyword list or map.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And here is the output for <code>get_author_by_twitter!/1</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; Bookstore.Store.get_author_by_twitter!("jeg2")
[debug] QUERY OK source="authors" db=6.1ms decode=0.8ms queue=1.1ms idle=1649.9ms
SELECT a0."id", a0."first_name", a0."last_name", a0."twitter_account", a0."inserted_at", a0."updated_at" FROM "authors" AS a0 WHERE (a0."twitter_account" = $1) ["jeg2"]
%Bookstore.Store.Author{
  __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
  first_name: "James",
  id: 2,
  inserted_at: ~N[2020-09-04 02:40:21],
  last_name: "Gray",
  twitter_account: "jeg2",
  updated_at: ~N[2020-09-04 02:40:21]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also use <code>Repo.get_by!/2</code> to fetch an entry based on multiple attributes.
In the next example, we will create a function that returns an entry based on
the <code>first_name</code> and <code>last_name</code>.</p>
</div>
<div class="listingblock">
<div class="title">lib/bookstore/store.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">[...]
  def get_author_by_first_name_last_name!(first_name, last_name) do
    Repo.get_by!(Author, first_name: first_name, last_name: last_name) <i class="conum" data-value="1"></i><b>(1)</b>
  end
[...]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Again, the second argument for <code>Repo.get_by!</code> is a keyword list, this time
containing two entries (for <code>first_name</code> and <code>last_name</code>).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is the output if the entry is found:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; Bookstore.Store.get_author_by_first_name_last_name!("Ulisses", "Almeida")
[debug] QUERY OK source="authors" db=6.3ms decode=0.7ms queue=1.0ms idle=405.5ms
SELECT a0."id", a0."first_name", a0."last_name", a0."twitter_account", a0."inserted_at", a0."updated_at" FROM "authors" AS a0 WHERE ((a0."first_name" = $1) AND (a0."last_name" = $2)) ["Ulisses", "Almeida"]
%Bookstore.Store.Author{
  __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
  first_name: "Ulisses",
  id: 3,
  inserted_at: ~N[2020-09-04 02:40:21],
  last_name: "Almeida",
  twitter_account: "ulissesalmeida",
  updated_at: ~N[2020-09-04 02:40:21]
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ecto-update"><a class="anchor" href="#ecto-update"></a>Update an Entry</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you want to change a dataset, you have to assign it to a variable first.
Assuming we want to update the <code>twitter_account</code> of the dataset with the <code>id</code> 1,
we would do the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">$ iex -S mix phx.server
[...]
iex(2)&gt; alias Bookstore.Store <i class="conum" data-value="1"></i><b>(1)</b>
Bookstore.Store
iex(3)&gt; alias Bookstore.Store.Author
Bookstore.Store.Author
iex(4)&gt; author = Store.get_author!(1) <i class="conum" data-value="2"></i><b>(2)</b>
[debug] QUERY OK source="authors" db=8.3ms decode=1.1ms queue=0.9ms idle=1955.5ms
SELECT a0."id", a0."first_name", a0."last_name", a0."twitter_account", a0."inserted_at", a0."updated_at" FROM "authors" AS a0 WHERE (a0."id" = $1) [1]
%Bookstore.Store.Author{
  __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
  first_name: "Dave",
  id: 1,
  inserted_at: ~N[2020-05-27 11:48:17],
  last_name: "Thomas",
  twitter_account: "pragdave",
  updated_at: ~N[2020-05-27 11:48:17]
}
iex(5)&gt; Store.update_author(author, %{twitter_account: nil}) <i class="conum" data-value="3"></i><b>(3)</b>
[debug] QUERY OK db=2.2ms queue=3.6ms idle=1569.2ms
UPDATE "authors" SET "twitter_account" = $1, "updated_at" = $2 WHERE "id" = $3 [nil, ~N[2020-05-28 10:54:55], 1]
{:ok,
 %Bookstore.Store.Author{
   __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
   first_name: "Dave",
   id: 1,
   inserted_at: ~N[2020-05-27 11:48:17],
   last_name: "Thomas",
   twitter_account: nil,
   updated_at: ~N[2020-05-28 10:54:55]
 }}
iex(6)&gt; Store.get_author!(1) <i class="conum" data-value="4"></i><b>(4)</b>
[debug] QUERY OK source="authors" db=4.8ms idle=659.0ms
SELECT a0."id", a0."first_name", a0."last_name", a0."twitter_account", a0."inserted_at", a0."updated_at" FROM "authors" AS a0 WHERE (a0."id" = $1) [1]
%Bookstore.Store.Author{
  __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
  first_name: "Dave",
  id: 1,
  inserted_at: ~N[2020-05-27 11:48:17],
  last_name: "Thomas",
  twitter_account: nil,
  updated_at: ~N[2020-05-28 10:54:55]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We set these aliases to make our lives a bit easier. No technical reason.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We fetch the dataset with the ID 1 and assign it to the variable <code>author</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>update_author/2</code> updates the <code>twitter_account</code> field in the database. You can read the SQL command.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Just checking if it worked.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ecto-associations"><a class="anchor" href="#ecto-associations"></a>Associations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section, we will look at how to define and work with associations between schemas.</p>
</div>
<div class="paragraph">
<p>There are three kinds of associations that we can use: one-to-one, one-to-many
and many-to-many. In the following example, we will look at the one-to-many
association. We will create an association in which each author is associated
with many books.</p>
</div>
<div class="paragraph">
<p>First, we need to generate a migration file to create the <code>books</code> table:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix ecto.gen.migration create_books
Compiling 1 file (.ex)
* creating priv/repo/migrations/20200907084536_create_books.exs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we need to edit the migration file to create the <code>books</code> table and to add
a reference to the <code>author</code>:</p>
</div>
<div class="listingblock">
<div class="title">priv/repo/migrations/20200907084536_create_books.exs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule Bookstore.Repo.Migrations.CreateBooks do
  use Ecto.Migration

  def change do
    create table(:books) do
      add :title, :string
      add :author_id, references(:authors) <i class="conum" data-value="1"></i><b>(1)</b>

      timestamps()
    end
  end
end</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This adds an <code>author_id</code> column to the <code>books</code> table which references an
entry in the <code>authors</code> table.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now run the migration by calling <code>mix ecto.migrate</code>:</p>
</div>
<div class="paragraph">
<p>We now need to add a <code>Bookstore.Store.Book</code> module with the schema for the
<code>books</code> table:</p>
</div>
<div class="listingblock">
<div class="title">lib/bookstore/store/book.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule Bookstore.Store.Book do
  use Ecto.Schema
  import Ecto.Changeset

  alias Bookstore.Store.Author

  schema "books" do
    field :title, :string
    belongs_to :author, Author <i class="conum" data-value="1"></i><b>(1)</b>

    timestamps()
  end

  @doc false
  def changeset(book, attrs) do
    book
    |&gt; cast(attrs, [:title, :author_id])
    |&gt; validate_required([:title, :author_id])
  end
end</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>belongs_to</code> macro makes the associated schema accessible through the
book.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We also need to make a small change to the <code>Bookstore.Store.Author</code> module:</p>
</div>
<div class="listingblock">
<div class="title">lib/bookstore/store/book.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">[...]
  schema "authors" do
    [...]
    has_many :books, Book <i class="conum" data-value="1"></i><b>(1)</b>
    [...]
  end
[...]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>has_many</code> lets us access the books through the author.</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="ecto-querying-associations"><a class="anchor" href="#ecto-querying-associations"></a>Querying Associations</h3>
<div class="paragraph">
<p>We have created the one-to-many association between <code>authors</code> and <code>books</code>, and
we have updated the schemas, so we can now start adding new <code>books</code> to the
database. To do this, we will add a <code>create_book</code> function to the
<code>Bookstore.Store</code> context module:</p>
</div>
<div class="listingblock">
<div class="title">lib/bookstore/store.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">[...]
  alias Bookstore.Store.Book

  def create_book(attrs) do
    %Book{}
    |&gt; Book.changeset(attrs)
    |&gt; Repo.insert()
  end
[...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we are ready to try this out in <code>iex</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; Bookstore.Store.create_book(%{title: "Programming Elixir", author_id: 1})
[debug] QUERY OK db=8.0ms decode=1.7ms queue=2.8ms idle=1669.3ms
INSERT INTO "books" ("author_id","title","inserted_at","updated_at") VALUES ($1,$2,$3,$4) RETURNING "id" [1, "Programming Elixir", ~N[2020-09-08 01:17:34], ~N[2020-09-08 01:17:34]]
{:ok,
 %Bookstore.Store.Book{
   __meta__: #Ecto.Schema.Metadata&lt;:loaded, "books"&gt;,
   author: #Ecto.Association.NotLoaded&lt;association :author is not loaded&gt;,
   author_id: 1,
   id: 4,
   inserted_at: ~N[2020-09-08 01:17:34],
   title: "Programming Elixir",
   updated_at: ~N[2020-09-08 01:17:34]
 }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We now want to write some queries to fetch this data from the database.
We will add two functions to the <code>Bookstore.Store</code> context module - one that
returns a list of an author&#8217;s books and one that fetches a book by querying the
title.</p>
</div>
<div class="listingblock">
<div class="title">lib/bookstore/store.ex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">[...]
  def list_books_by_author(author) do
    Book
    |&gt; where(author_id: ^author.id) <i class="conum" data-value="1"></i><b>(1)</b>
    |&gt; Repo.all()
  end
[...]
  def get_book_by_title!(title) do
    Repo.get_by!(Book, title: title)
  end
[...]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>When using external values in query expressions, we need to prefix the
value with a <code>^</code> sign. We will look at the <code>where</code> macro later, when we start
using more complex queries.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s see how these queries work in <code>iex</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; author = Bookstore.Store.get_author_by_twitter!("pragdave") <i class="conum" data-value="1"></i><b>(1)</b>
[debug] QUERY OK source="authors" db=6.0ms decode=0.8ms queue=1.3ms idle=1390.3ms
SELECT a0."id", a0."first_name", a0."last_name", a0."twitter_account", a0."inserted_at", a0."updated_at" FROM "authors" AS a0 WHERE (a0."twitter_account" = $1) ["pragdave"]
%Bookstore.Store.Author{
  __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
  books: #Ecto.Association.NotLoaded&lt;association :books is not loaded&gt;,
  first_name: "Dave",
  id: 1,
  inserted_at: ~N[2020-09-08 01:56:38],
  last_name: "Thomas",
  twitter_account: "pragdave",
  updated_at: ~N[2020-09-08 01:56:38]
}
iex(2)&gt; Bookstore.Store.list_books_by_author(author)
[debug] QUERY OK source="books" db=1.3ms queue=1.4ms idle=1802.0ms
SELECT b0."id", b0."title", b0."author_id", b0."inserted_at", b0."updated_at" FROM "books" AS b0 WHERE (b0."author_id" = $1) [1]
[
  %Bookstore.Store.Book{
    __meta__: #Ecto.Schema.Metadata&lt;:loaded, "books"&gt;,
    author: #Ecto.Association.NotLoaded&lt;association :author is not loaded&gt;, <i class="conum" data-value="2"></i><b>(2)</b>
    author_id: 1,
    id: 1,
    inserted_at: ~N[2020-09-08 01:56:51],
    title: "Programming Elixir",
    updated_at: ~N[2020-09-08 01:56:51]
  }
]
iex(3)&gt; Bookstore.Store.get_book_by_title!("Programming Elixir")
[debug] QUERY OK source="books" db=1.6ms queue=3.6ms idle=969.6ms
SELECT b0."id", b0."title", b0."author_id", b0."inserted_at", b0."updated_at" FROM "books" AS b0 WHERE (b0."title" = $1) ["Programming Elixir"]
%Bookstore.Store.Book{
  __meta__: #Ecto.Schema.Metadata&lt;:loaded, "books"&gt;,
  author: #Ecto.Association.NotLoaded&lt;association :author is not loaded&gt;,
  author_id: 1,
  id: 1,
  inserted_at: ~N[2020-09-08 01:56:51],
  title: "Programming Elixir",
  updated_at: ~N[2020-09-08 01:56:51]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We fetch the <code>author</code> as we need to use it in the <code>list_books_by_author/1</code> function.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>By default, the associated data (in this case, the <code>author</code> data) is not
loaded. In the next subsection, we will look at how to load this data.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ecto-preloading-associated-data"><a class="anchor" href="#ecto-preloading-associated-data"></a>Preloading Associated Data</h3>
<div class="paragraph">
<p>As can be seen in the examples above, the data for an associated table is not
loaded by default. To request this data, we need to preload it, using either
<code>Ecto.Query.preload</code> or <code>Ecto.Repo.preload</code>. In this subsection, we will use
<code>Ecto.Repo.preload</code>, which allows us to preload structs after they have been
fetched from the database.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s open up <code>iex</code> and see how preloading data works:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; elixir_book = Bookstore.Store.get_book_by_title!("Programming Elixir") <i class="conum" data-value="1"></i><b>(1)</b>
[debug] QUERY OK source="books" db=5.9ms decode=0.7ms queue=1.1ms idle=809.0ms
SELECT b0."id", b0."title", b0."author_id", b0."inserted_at", b0."updated_at" FROM "books" AS b0 WHERE (b0."title" = $1) ["Programming Elixir"]
%Bookstore.Store.Book{
  __meta__: #Ecto.Schema.Metadata&lt;:loaded, "books"&gt;,
  author: #Ecto.Association.NotLoaded&lt;association :author is not loaded&gt;,
  author_id: 1,
  id: 1,
  inserted_at: ~N[2020-09-08 01:56:51],
  title: "Programming Elixir",
  updated_at: ~N[2020-09-08 01:56:51]
}
iex(2)&gt; Bookstore.Repo.preload(elixir_book, :author) <i class="conum" data-value="2"></i><b>(2)</b>
[debug] QUERY OK source="authors" db=0.5ms queue=0.8ms idle=151.0ms
SELECT a0."id", a0."first_name", a0."last_name", a0."twitter_account", a0."inserted_at", a0."updated_at", a0."id" FROM "authors" AS a0 WHERE (a0."id" = $1) [1]
%Bookstore.Store.Book{
  __meta__: #Ecto.Schema.Metadata&lt;:loaded, "books"&gt;,
  author: %Bookstore.Store.Author{ <i class="conum" data-value="3"></i><b>(3)</b>
    __meta__: #Ecto.Schema.Metadata&lt;:loaded, "authors"&gt;,
    books: #Ecto.Association.NotLoaded&lt;association :books is not loaded&gt;,
    first_name: "Dave",
    id: 1,
    inserted_at: ~N[2020-09-08 01:56:38],
    last_name: "Thomas",
    twitter_account: "pragdave",
    updated_at: ~N[2020-09-08 01:56:38]
  },
  author_id: 1,
  id: 1,
  inserted_at: ~N[2020-09-08 01:56:51],
  title: "Programming Elixir",
  updated_at: ~N[2020-09-08 01:56:51]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We first fetch the <code>book</code> with the title "Programming Elixir".</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We use a single atom to preload a single association. To preload multiple
associations, we would use a list of atoms.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We can now see the associated (<code>author</code>) data.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For more information about associations, see
<a href="https://hexdocs.pm/ecto/2.2.11/associations.html" class="bare">https://hexdocs.pm/ecto/2.2.11/associations.html</a></p>
</div>
<div class="paragraph">
<p><mark>Work in progess</mark></p>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>Copyright (C) 2020-2020 Stefan Wintermeyer - <a href="https://www.wintermeyer-consulting.de">wintermeyer-consulting.de</a> - Twitter: <a href="https://twitter.com/wintermeyer">@wintermeyer</a></p>
  <p>This webpage was built with <a href="https://antora.org">Antora</a>.</p>
</footer>
<script src="../../antora-assets/js/site.js"></script>
<script async src="../../antora-assets/js/vendor/highlight.js"></script>
  </body>
</html>

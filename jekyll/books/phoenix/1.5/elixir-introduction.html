<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Elixir Introduction :: Phoenix Beginner&#x27;s Guide</title>
    <link rel="canonical" href="https://www.wintermeyer-consulting.de/books/phoenix/phoenix/1.5/elixir-introduction.html">
    <meta name="generator" content="Antora 2.3.1">
    <link rel="stylesheet" href="../../antora-assets/css/site.css">
    <link rel="stylesheet" href="../../antora-assets/css/site-extra.css">
  </head>
  <body class="article">
<header class="header" role="banner">
  <nav class="navbar">
    <div class="navbar-brand">
      <div class="navbar-item">
        <a href="/">Wintermeyer Consulting</a>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item has-dropdown is-hoverable">
          <div class="navbar-link">Phoenix Links</div>
          <div class="navbar-dropdown">
            <div class="navbar-item"><strong>Phoenix Framework</strong></div>
            <a class="navbar-item" href="https://www.phoenixframework.org">Phoenix Homepage</a>
            <a class="navbar-item" href="https://github.com/phoenixframework/phoenix">GitHub Repository</a>
            <hr class="navbar-divider">
            <div class="navbar-item"><strong>Elixir</strong></div>
            <a class="navbar-item" href="https://elixir-lang.org">Elixir Homepage</a>
            <a class="navbar-item" href="https://github.com/elixir-lang/elixir">GitHub Repository</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <div class="navbar-link">Stefan Wintermeyer</div>
          <div class="navbar-dropdown">
            <div class="navbar-item"><strong>Work related</strong></div>
            <a class="navbar-item" href="https://www.wintermeyer-consulting.de">Training and Consulting</a>
            <a class="navbar-item"
              href="https://speakerdeck.com/wintermeyer">SpeakerDeck</a>
            <hr class="navbar-divider">
            <div class="navbar-item"><strong>Phoenix projects</strong></div>
            <a class="navbar-item"
              href="https://www.vutuv.de/users/stefan.wintermeyer">vutuv</a>
            <a class="navbar-item"
              href="https://www.mehr-schulferien.de">Schulferien Deutschland</a>
            <div class="navbar-item"><strong>Private</strong></div>
            <a class="navbar-item" href="https://www.wintermeyer.de">Personal Homepage</a>
            <div class="navbar-item"><strong>Social Media</strong></div>
            <a class="navbar-item" href="https://twitter.com/wintermeyer">Twitter</a>
            <a class="navbar-item" href="https://www.facebook.com/stefan.wintermeyer">Facebook</a>
            <a class="navbar-item"
              href="https://www.instagram.com/wintermeyer/">Instagram</a>
          </div>
        </div>
        <a class="navbar-item" href="https://twitter.com/wintermeyer">
          <span class="icon">
            <svg aria-hidden="true" data-icon="twitter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
              <path fill="#57aaee" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path>
            </svg>
          </span>
        </a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="phoenix" data-version="1.5">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">Phoenix Beginner&#x27;s Guide</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index.html#preface">Preface</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="elixir-introduction.html">Elixir Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="phoenix-basics.html">Phoenix Basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-basics.html#the-base-setup">The Base Setup</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-basics.html#hello-world">Hello World!</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="phoenix-basics.html#conn-struct">The conn Struct</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="phoenix-basics.html#static-clock">Static Clock</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-basics.html#links">Links</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="phoenix-basics.html#static-files">Static files</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="phoenix-basics.html#images">Images</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-basics.html#css">CSS</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="phoenix-liveview-basics.html">LiveView Basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-liveview-basics.html#light-switch">Light Switch</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-liveview-basics.html#clock">Clock</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-liveview-basics.html#counter">Counter</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-liveview-basics.html#aiport-code-search">Airport Code Search</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-liveview-basics.html#autocomplete">Autocomplete</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="router.html">Router</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="router.html#mix-phx-routes">Display all existing routes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="router.html#router-params">Params</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="router.html#router-query-string">Query Strings</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="router.html#router-multilevel-paths">Multilevel Paths</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="router.html#router-wildcards">Wildcards</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index.html#training">Remote Training</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Phoenix Beginner&#x27;s Guide</span>
    <span class="version">1.5</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Phoenix Beginner's Guide</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">1.5</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Phoenix Beginner's Guide</a></li>
    <li><a href="elixir-introduction.html">Elixir Introduction</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<article class="doc">
<h1 class="page">Elixir Introduction</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This chapter will teach you the absolut basics of Elixir. Just enough to become
productive with Phoenix. There is a lot more to learn and to understand about
Elixir.</p>
</div>
<div class="paragraph">
<p>Buckle up. It is going to be a bumpy and sometimes boring ride. It&#8217;s tough to
teach all the needed Elixir knowledge in just one chapter.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Elixir version</div>
<div class="paragraph">
<p>All code examples are written and tested for Elixir version 1.10.2.
Please make sure that you have that or a higher version installed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ elixir -v
Erlang/OTP 22 [erts-10.6.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Elixir 1.10.2 (compiled with Erlang/OTP 21)</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elixir-introduction-iex"><a class="anchor" href="#elixir-introduction-iex"></a>Elixir&#8217;s Interactive Shell (iex)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Your Elixir installation comes with an Elixir&#8217;s Interactive Shell (<code>iex</code>) which we
will use for most examples in this chapter. Please go to your command line and
fire it up:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">$ iex
Erlang/OTP 22 [erts-10.6.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Interactive Elixir (1.10.2) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&gt; <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is your iex prompt.</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You have to press <code>CTRL-C</code> twice(!) to stop the <code>iex</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>iex</code> will be your trusted friend during the work with this book and later
while working with Phoenix. While programming in development mode you can use it
to dive into the core of your Phoenix application. You can do so too while
being in production mode but that is the equivalent to an open heard surgery. It can
be a life saver but you really need to know what you are doing.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The iex offers autocomplete when possible. So when in doubt press <code>TAB</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The iex offers a history too. To recycle the last command just press on the arrow-up key.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_help_in_the_iex"><a class="anchor" href="#_help_in_the_iex"></a>Help in the iex</h3>
<div class="paragraph">
<p>The iex has a build in help function <code>h/1</code> which gives you access to some
basic documentation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(2)&gt; h length/1

                                def length(list)

  @spec length(list()) :: non_neg_integer()

guard: true

Returns the length of list.

Allowed in guard tests. Inlined by the compiler.

# Examples

    iex&gt; length([1, 2, 3, 4, 5, 6, 7, 8, 9])
    9</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_run_the_code_examples_not_in_iex"><a class="anchor" href="#_run_the_code_examples_not_in_iex"></a>Run the code examples not in iex</h3>
<div class="paragraph">
<p>If you prefer to run all code examples not in the <code>iex</code> you can do so. Just put
them in a file with the ending <code>.exs</code> and call that file from the command file
with <code>elixir example.exs</code>.</p>
</div>
<div class="paragraph">
<p>When tackling deployment I&#8217;ll discuss how to compile the code.
<code>elixir example.exs</code> does not compile it.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elixir-introduction-hello-world"><a class="anchor" href="#elixir-introduction-hello-world"></a>Hello world!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The classic! But never the less very important. You can use the function
<code>IO.puts()</code> to print a string to standard output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; IO.puts("Hello world!")
Hello world!
:ok</code></pre>
</div>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Strings are always encapsuled within double quotes. In case you need to have
double quotes within a string you have to escape them with backslashes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(2)&gt; IO.puts("With double quotes: \"Hello world!\"")
With double quotes: "Hello world!"
:ok
iex(3)&gt;
BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution
^C<i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Don&#8217;t be afraid of the <code>BREAK</code> menue. With the first <code>Ctrl+C</code> the <code>iex</code>
displays this list of choices (the <code>BREAK</code> menu) and with the second <code>Ctrl+C</code>
you end the <code>iex</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elixir-introduction-basic-calculations"><a class="anchor" href="#elixir-introduction-basic-calculations"></a>Basic Calculations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We can use the types <code>integer</code> (Integer numbers) and <code>float</code> (Real numbers) to
do all sorts of calcuations. We can use the usual operators. I&#8217;ll show you a
couple of examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">$ iex
Erlang/OTP 22 [erts-10.6.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Interactive Elixir (1.10.2) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&gt; 1 + 1
2
iex(2)&gt; 1.1 + 1
2.1
iex(3)&gt; 2 - 1
1
iex(4)&gt; 10 * 1000000000000000
10000000000000000
iex(5)&gt; 23 / 3
7.666666666666667
iex(6)&gt;
BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution
^C</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If it&#8217;s OK with you I&#8217;ll skip the <code>iex</code> and the <code>BREAK</code> part in the rest
of this chapter. By that we get more real estate for the essential stuff and less trees
have to die to get the book version printed.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elixir-introduction-atoms"><a class="anchor" href="#elixir-introduction-atoms"></a>Atoms</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An atom just consists of it&#8217;s own name. In some other programming languages they
are called symbols. Atoms start with a <code>:</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; :red
:red
iex(2)&gt; :blue
:blue</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Atom names can be written in snake_case or in CamelCase. But the usual Elixir
convention is to use snake_case.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_booleans_are_atoms_too"><a class="anchor" href="#_booleans_are_atoms_too"></a>Booleans are atoms too</h3>
<div class="paragraph">
<p>Booleans are a good example for the use of atoms. But they are special because
you don&#8217;t have to prefix them with a <code>:</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; false == :false <i class="conum" data-value="1"></i><b>(1)</b>
true
iex(2)&gt; is_atom(false) <i class="conum" data-value="2"></i><b>(2)</b>
true
iex(3)&gt; is_boolean(:false) <i class="conum" data-value="3"></i><b>(3)</b>
true</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We haven&#8217;t talked about logical expressions yet. But you know how '==' works.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The function <code>is_atom()</code> can be used to check if something is an atom.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The function <code>is_boolean()</code> can be used to check if something is a boolean.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elixir-introduction-logical-expressions"><a class="anchor" href="#elixir-introduction-logical-expressions"></a>Logical Expressions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A type <code>boolean</code> can store the values <code>true</code> and <code>false</code>. Together with <code>and</code>,
<code>or</code> and <code>not</code> those can create expressions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; true and true
true
iex(2)&gt; false and false
false
iex(3)&gt; true or false
true
iex(4)&gt; not true
false</code></pre>
</div>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>The operators <code>and</code>, <code>or</code> and <code>not</code> can only work with boolean values. The operators
<code>&amp;&amp;</code> (and), <code>||</code> (or) and <code>!</code> (not) basically do the same but are a bit more free spirited and accept <strong>truthy</strong> and <strong>falsy</strong> values. We will get to that later if needed.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elixir-introduction-variables"><a class="anchor" href="#elixir-introduction-variables"></a>Variables</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>You already know how variables work from experiences in other programming
languages. Therefor we can dive right into it. Variable names follow the
<a href="https://en.wikipedia.org/wiki/Snake_case">snake_case</a> format and start with a
lower case. Some examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; length = 10 <i class="conum" data-value="1"></i><b>(1)</b>
10
iex(2)&gt; width = 23
23
iex(3)&gt; area = length * width
230</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We use the operator <code>=</code> to bind the value 10 to the variable with the name <code>length</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you start a variable name with a capital error you&#8217;ll get an error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(4)&gt; Radius = 2
** (MatchError) no match of right hand side value: 2 <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Yes, <code>MatchError</code> is a rather strange error message here. It will make more
sense later. Binding values in variables is a bit more complicated than it seems
right now.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elixir-introduction-strings"><a class="anchor" href="#elixir-introduction-strings"></a>Strings</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>We already used a string in the <a href="#elixir-introduction-hello-world">Hello World</a> example.
The use is for variables is straight forward:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; first_name = "Stefan" <i class="conum" data-value="1"></i><b>(1)</b>
"Stefan"
iex(2)&gt; last_name = "Wintermeyer"
"Wintermeyer"
iex(3)&gt; name = first_name &lt;&gt; " " &lt;&gt; last_name <i class="conum" data-value="2"></i><b>(2)</b>
"Stefan Wintermeyer"
iex(4)&gt; greeting = "Hello #{first_name}!" <i class="conum" data-value="3"></i><b>(3)</b>
"Hello Stefan!"
iex(5)&gt; counter = 23
23
iex(6)&gt; "Count: #{counter}" <i class="conum" data-value="4"></i><b>(4)</b>
"Count: 23"</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We assign the string "Stefan" to the variable with the name <code>first_name</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>&lt;&gt;</code> operator can be used to concatinate strings.
</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>#{}</code> is Elixir&#8217;s expressive string-interpolation.
It can be used to inject a variable into a string which is encapsuled
within double quotes.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Elixir&#8217;s expressive string-interpolation even works with integers.
String-interpolation is done by the <code>Kernel.to_string/1</code> macro which evokes
<code>String.Chars</code>. It can handle integers, floats, some lists (later more on lists)
and atoms (later more on atoms) out of the box.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_anonymous_functions"><a class="anchor" href="#_anonymous_functions"></a>Anonymous Functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Functions are the method in a functional programming language to handle subprograms.
Let me show you an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; greeting = fn name -&gt; "Hello #{name}!" end <i class="conum" data-value="1"></i><b>(1)</b>
#Function&lt;7.126501267/1 in :erl_eval.expr/5&gt;
iex(2)&gt; greeting.("Bob") <i class="conum" data-value="2"></i><b>(2)</b>
"Hello Bob!"
iex(3)&gt; greeting.("Alice")
"Hello Alice!"
iex(4)&gt; square_area = fn(a) -&gt; a * a end <i class="conum" data-value="3"></i><b>(3)</b>
#Function&lt;7.126501267/1 in :erl_eval.expr/5&gt;
iex(5)&gt; square_area.(10)
100</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We create a function and bind it to the variable <code>greeting</code>.
<div class="ulist">
<ul>
<li>
<p><code>fn</code> tells Elixir that you want to define a function.</p>
</li>
<li>
<p><code>name</code> is a parameter we can use to inject values.</p>
</li>
<li>
<p><code>&#8594;</code> is the operator to indicate the the following expression is the body of the function.</p>
</li>
<li>
<p><code>end</code> indicates the end of the function.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We use the <code>.</code> (dot) operator to pass a value to the function.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Feel free to use parentheses: <code>fn(a)</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These simple functions are called <strong>anonymous functions</strong>. They have no global
name and must be bound to a variable.</p>
</div>
<div class="paragraph">
<p>Most times anonmous functions are simple one liners. But they don&#8217;t have to be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; circular_area = fn radius -&gt;
...(1)&gt;   pi = 3.14159265359
...(1)&gt;   pi * radius * radius
...(1)&gt; end
#Function&lt;7.126501267/1 in :erl_eval.expr/5&gt;
iex(2)&gt; circular_area.(3)
28.274333882310003</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes it makes sense to create a function without an argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; tomorrow = fn -&gt; Date.add(Date.utc_today(), 1) end <i class="conum" data-value="1"></i><b>(1)</b>
#Function&lt;21.126501267/0 in :erl_eval.expr/5&gt;
iex(2)&gt; tomorrow.() <i class="conum" data-value="2"></i><b>(2)</b>
~D[2020-05-07]
iex(3)&gt; Date.utc_today() <i class="conum" data-value="3"></i><b>(3)</b>
~D[2020-05-06]
iex(4)&gt; tomorrow <i class="conum" data-value="4"></i><b>(4)</b>
#Function&lt;21.126501267/0 in :erl_eval.expr/5&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Yes, we haven&#8217;t discussed <code>Date.add</code> or <code>Date.utc_today()</code> yet. But you are smart enough to figure out what they do.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Call the function <code>tomorrow</code> without a parameter.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Just double check.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Calling <code>tomorrow</code> without the <code>.</code> (dot) operator will not trigger the function.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sometimes you need a function with multiple arguments. Those are seperated by commas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; area = fn a, b -&gt; a * b end <i class="conum" data-value="1"></i><b>(1)</b>
#Function&lt;13.126501267/2 in :erl_eval.expr/5&gt;
iex(2)&gt; area.(2,8)
16
iex(3)&gt; volumne = fn a, b, c -&gt; a * b * c end
#Function&lt;19.126501267/3 in :erl_eval.expr/5&gt;
iex(4)&gt; volumne.(10,10,10) <i class="conum" data-value="2"></i><b>(2)</b>
1000</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Two parameters (a and b).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Three parameters (a, b and c).</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A function can not have more than 255 parameters. As a rule of thumb I suggest you never
use more than 5 parameters. That is always an indicator that you should refactor your code.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_functions_are_first_class_citizens"><a class="anchor" href="#_functions_are_first_class_citizens"></a>Functions are First-Class Citizens</h3>
<div class="paragraph">
<p>In Elixir a function is a value of the type <code>function</code>. So they are just like any
other value. That means you can programm a function that expects an other function as
a parameter.</p>
</div>
<div class="paragraph">
<p>It&#8217;s hard to find a somehow meaningful example for this with our current Elixir
know-how. Germany has two kinds of value added taxes (VAT). The default is 19%
and the reduced one (e.g. for some foods) is 7%.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; food_vat = fn price -&gt; price * 0.07 end <i class="conum" data-value="1"></i><b>(1)</b>
#Function&lt;7.126501267/1 in :erl_eval.expr/5&gt;
iex(2)&gt; vat = fn price -&gt; price * 0.19 end <i class="conum" data-value="2"></i><b>(2)</b>
#Function&lt;7.126501267/1 in :erl_eval.expr/5&gt;
iex(3)&gt; total_price = fn price, vat -&gt; price + vat.(price) end <i class="conum" data-value="3"></i><b>(3)</b>
#Function&lt;13.126501267/2 in :erl_eval.expr/5&gt;
iex(4)&gt; total_price.(10, food_vat) <i class="conum" data-value="4"></i><b>(4)</b>
10.7
iex(5)&gt; total_price.(10, vat)
11.9</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This function calculates the 7% VAT.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This function calculates the 19% VAT.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This function calculates the total price which includes the tax. You see that the second parameter is a function.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Example calculation which uses the <code>food_vat</code> function as the second parameter.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_operator"><a class="anchor" href="#_the_operator"></a>The &amp; operator</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>It is likely that you will stumble upon the <code>&amp;</code> operator while searching
solutions for Elixir problems. It is a so called <strong>capture operator</strong>. It
is a syntactical shortcut for anonymous functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; square_area = fn a -&gt; a * a end <i class="conum" data-value="1"></i><b>(1)</b>
#Function&lt;7.126501267/1 in :erl_eval.expr/5&gt;
iex(2)&gt; square_area2 = &amp;(&amp;1 * &amp;1) <i class="conum" data-value="2"></i><b>(2)</b>
#Function&lt;7.126501267/1 in :erl_eval.expr/5&gt;
iex(3)&gt; square_area.(8)
64
iex(4)&gt; square_area2.(9)
81
iex(5)&gt; rectangle_area = &amp;(&amp;1 * &amp;2) <i class="conum" data-value="3"></i><b>(3)</b>
&amp;:erlang.*/2
iex(6)&gt; rectangle_area.(7,8)
56</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A normal anonymous function to calculate the area of a square.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The same calculation but a different syntax. We use the &amp; operator. No need for a <code>fn</code> and <code>end</code> with this operator.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Multiple parameter can be used too (e.g. <code>&amp;1</code>, <code>&amp;2</code>).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sometimes it is easier to read code which uses the <code>&amp;</code> operator. Sometimes it is not.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_variable_scopes"><a class="anchor" href="#_variable_scopes"></a>Variable Scopes</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>In every programming language variables have some sort of scope. Let&#8217;s have a look
into some code to figure out how variables in Elixr are scoped:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; area = 5 <i class="conum" data-value="1"></i><b>(1)</b>
5
iex(2)&gt; IO.puts(area)
5
:ok
iex(3)&gt; square_area = fn a -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
...(3)&gt;   area = a * a <i class="conum" data-value="3"></i><b>(3)</b>
...(3)&gt;   area
...(3)&gt; end
#Function&lt;7.126501267/1 in :erl_eval.expr/5&gt;
iex(4)&gt; square_area.(10) <i class="conum" data-value="4"></i><b>(4)</b>
100
iex(5)&gt; IO.puts(area) <i class="conum" data-value="5"></i><b>(5)</b>
5
:ok</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We bind the value of 5 to the variable <code>area</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We define an anonymous function.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Within this function we bind the result of our calculation to an other variable <code>area</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Run the function with the parameter 10. That would mean that the <code>area</code> in the function gets set to the value 100.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The original <code>area</code> hasn&#8217;t changed a bit. Because it is in a different scope.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>area</code> within the function is in an inner scope. The original <code>area</code> is in an outer scope.</p>
</div>
<div class="paragraph">
<p>But it gets a bit more complex:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; pi = 3.14159265359 <i class="conum" data-value="1"></i><b>(1)</b>
3.14159265359
iex(2)&gt; circular_area = fn radius -&gt; pi * radius * radius end <i class="conum" data-value="2"></i><b>(2)</b>
#Function&lt;7.126501267/1 in :erl_eval.expr/5&gt;
iex(3)&gt; circular_area.(10)
314.15926535899996</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We bind the value 3.14159265359 to the variable with the name <code>pi</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We create an anonymous function which uses the variable <code>pi</code> to make the calculation.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>So we can read the outer scope variable from within the function. So lets check if we can change it too:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; pi = 3.14159265359 <i class="conum" data-value="1"></i><b>(1)</b>
3.14159265359
iex(2)&gt; circular_area = fn radius -&gt;
...(2)&gt;   pi = 3.14 <i class="conum" data-value="2"></i><b>(2)</b>
...(2)&gt;   pi * radius * radius
...(2)&gt; end
#Function&lt;7.126501267/1 in :erl_eval.expr/5&gt;
iex(3)&gt; circular_area.(10) <i class="conum" data-value="3"></i><b>(3)</b>
314.0
iex(4)&gt; IO.puts(pi) <i class="conum" data-value="4"></i><b>(4)</b>
3.14159265359
:ok</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We bind the value 3.14159265359 to the variable with the name <code>pi</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We bind the inner scoped variable <code>pi</code> with the value 3.14.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The 3.14 and not the 3.14159265359 gets used.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The outer scoped <code>pi</code> is not changed.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can not change the value of an outer scoped variable but you can read
it. And you can create a new inner scope variable with the same name without
interacting with the outer scoped one.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_functions_and_modules"><a class="anchor" href="#_functions_and_modules"></a>Functions and Modules</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Anonymous functions are useful but using just them to build a big software
project would become messy very fast. We need a better way to structure our
code. Let me introduce you to Modules which are used to organize a collection of
functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Store do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;   def total_price(price, amount) do <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;     price * amount
...(1)&gt;   end
...(1)&gt; end
{:module, Store,
 &lt;&lt;70, 79, 82, 49, 0, 0, 5, 4, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 133, 0,
   0, 0, 14, 12, 69, 108, 105, 120, 105, 114, 46, 83, 116, 111, 114, 101, 8, 95,
   95, 105, 110, 102, 111, 95, 95, 7, ...&gt;&gt;, {:total_price, 2}}
iex(2)&gt; Store.total_price(10,7) <i class="conum" data-value="3"></i><b>(3)</b>
70</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>defmodule</code> is the keyword to define a module. The name of a modul starts with a capital letter.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>def</code> is the keyword to define a function within a module.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A function of a given module can be called from outside the module with this syntax.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>defmodule</code> and <code>def</code> use a <code>do &#8230;&#8203; end</code> construct to begin and end.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Moduel names use CamelCase which start with a capital letter. Function names use snake_case which start with a lower case letter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Normaly a module contains more than one function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Area do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;   def rectangle(a, b) do <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;     a * b
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def square(a) do <i class="conum" data-value="3"></i><b>(3)</b>
...(1)&gt;     a * a
...(1)&gt;   end
...(1)&gt; end
{:module, Area,
 &lt;&lt;70, 79, 82, 49, 0, 0, 5, 156, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 137,
   0, 0, 0, 15, 11, 69, 108, 105, 120, 105, 114, 46, 65, 114, 101, 97, 8, 95,
   95, 105, 110, 102, 111, 95, 95, 7, 99, ...&gt;&gt;, {:square, 1}}
iex(2)&gt; Area.rectangle(4,5)
20
iex(3)&gt; Area.square(4)
16</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We call this module 'Area'.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The function rectangle/2 calculates the area of a rectangle.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The function square/1 calculates the area of a square.</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_private_functions"><a class="anchor" href="#_private_functions"></a>Private Functions</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Sometimes you want to define a function within a module without exposing it to the outside world.
This can be done with a private functions which gets declared with <code>devp</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Area do
...(1)&gt;   def circle(radius) do
...(1)&gt;     pi() * radius * radius
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   defp pi do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;     3.14
...(1)&gt;   end
...(1)&gt; end
{:module, Area,
 &lt;&lt;70, 79, 82, 49, 0, 0, 5, 104, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 130,
   0, 0, 0, 15, 11, 69, 108, 105, 120, 105, 114, 46, 65, 114, 101, 97, 8, 95,
   95, 105, 110, 102, 111, 95, 95, 7, 99, ...&gt;&gt;, {:pi, 0}}
iex(2)&gt; Area.circle(10) <i class="conum" data-value="2"></i><b>(2)</b>
314.0
iex(3)&gt; Area.pi <i class="conum" data-value="3"></i><b>(3)</b>
** (UndefinedFunctionError) function Area.pi/0 is undefined or private
    Area.pi()</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The function <code>pi/0</code> is a private function.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The function <code>circle/1</code> can be called from the outsite. It can use the private function <code>pi/0</code> from within the module.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The function <code>pi/0</code> can not be called from the outsite.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_function_arity"><a class="anchor" href="#_function_arity"></a>Function Arity</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>In the last couple of sentences you probably recognized the names of a functions
with the number of parameters following. <code>pi/0</code> let to <code>defp pi do</code> and
<code>circle/1</code> to <code>circle(radius)</code>. This number or arguments or parameters is called
<strong>arity</strong>. Arity is kind of a big thing in Elixir. Why? Because not just the
function name but also the arity defines a function. If we want to create a
module which calculates the area of rectangles it could look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Rectangle do
...(1)&gt;   def area(a) do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;     a * a
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def area(a, b) do <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;     a * b
...(1)&gt;   end
...(1)&gt; end
{:module, Rectangle,
 &lt;&lt;70, 79, 82, 49, 0, 0, 5, 108, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 130,
   0, 0, 0, 14, 16, 69, 108, 105, 120, 105, 114, 46, 82, 101, 99, 116, 97, 110,
   103, 108, 101, 8, 95, 95, 105, 110, 102, ...&gt;&gt;, {:area, 2}}
iex(2)&gt; Rectangle.area(9) <i class="conum" data-value="3"></i><b>(3)</b>
81
iex(3)&gt; Rectangle.area(4,5) <i class="conum" data-value="4"></i><b>(4)</b>
20</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The function ´area/1´ with the arity of 1 accepts one parameter.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The function ´area/2´ with the arity of 2 accepts two parameters.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>So to calculate the area of a square you can call <code>area/1</code> with just one parameter.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>All non square rectangle areas have to be calculated with <code>area/2</code> which accepts two parameters.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_hierachical_modules"><a class="anchor" href="#_hierachical_modules"></a>Hierachical Modules</h3>
<div class="paragraph">
<p>In a big project you will have multiple layers of Module namespaces to keep everything in
some sort of structure.</p>
</div>
<div class="paragraph">
<p>This can be done by adding <code>.</code> between the Module names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Calculator.Area do
...(1)&gt;   def square(a) do
...(1)&gt;     a * a
...(1)&gt;   end
...(1)&gt; end
{:module, Calculator.Area,
 &lt;&lt;70, 79, 82, 49, 0, 0, 4, 232, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 138,
   0, 0, 0, 14, 22, 69, 108, 105, 120, 105, 114, 46, 67, 97, 108, 99, 117, 108,
   97, 116, 111, 114, 46, 65, 114, 101, 97, ...&gt;&gt;, {:square, 1}}
iex(2)&gt; Calculator.Area.square(5)
25</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is just a shortcut. You could also nest the Modules:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Calculator do
...(1)&gt;   defmodule Area do
...(1)&gt;     def square(a) do
...(1)&gt;       a * a
...(1)&gt;     end
...(1)&gt;   end
...(1)&gt; end
{:module, Calculator,
 &lt;&lt;70, 79, 82, 49, 0, 0, 3, 164, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 124,
   0, 0, 0, 12, 17, 69, 108, 105, 120, 105, 114, 46, 67, 97, 108, 99, 117, 108,
   97, 116, 111, 114, 8, 95, 95, 105, 110, ...&gt;&gt;,
 {:module, Calculator.Area,
  &lt;&lt;70, 79, 82, 49, 0, 0, 4, 232, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 138,
    0, 0, 0, 14, 22, 69, 108, 105, 120, 105, 114, 46, 67, 97, 108, 99, 117, 108,
    97, 116, 111, 114, 46, ...&gt;&gt;, {:square, 1}}}
iex(2)&gt; Calculator.Area.square(5)
25</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_import"><a class="anchor" href="#_import"></a>Import</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>We can import access to public functions from other modules. So that we don&#8217;t
have to use their fully qualified name.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Rectangle do
...(1)&gt;   def area(a) do
...(1)&gt;     a * a
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def area(a, b) do
...(1)&gt;     a * b
...(1)&gt;   end
...(1)&gt; end
{:module, Rectangle,
 &lt;&lt;70, 79, 82, 49, 0, 0, 5, 108, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 130,
   0, 0, 0, 14, 16, 69, 108, 105, 120, 105, 114, 46, 82, 101, 99, 116, 97, 110,
   103, 108, 101, 8, 95, 95, 105, 110, 102, ...&gt;&gt;, {:area, 2}}
iex(2)&gt; import Rectangle <i class="conum" data-value="1"></i><b>(1)</b>
Rectangle
iex(3)&gt; area(5) <i class="conum" data-value="2"></i><b>(2)</b>
25</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Here we <code>import Rectangle</code> to have all the functions of that module at our fingertips.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>No need to <code>Rectangle.area/1</code> any more <code>area/1</code> is just fine.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And you can also just import special functions from that module:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(3)&gt; import Rectangle, only: [area: 2] <i class="conum" data-value="1"></i><b>(1)</b>
Rectangle
iex(4)&gt; area(1) <i class="conum" data-value="2"></i><b>(2)</b>
** (CompileError) iex:7: undefined function area/1

iex(7)&gt; area(1,5) <i class="conum" data-value="3"></i><b>(3)</b>
5</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Let&#8217;s just import <code>area/2</code> but not all the other functions of that module.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>I try to run <code>area/1</code> but that throughts an error because I didn&#8217;t import it.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Just works fine.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When ever you just use a given function without a module name before
that module has already been imported by Elixir (e.g. the <code>Kernel</code> modul gets
imported automatically).
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_import_hierarchical_modules"><a class="anchor" href="#_import_hierarchical_modules"></a>Import Hierarchical Modules</h4>
<div class="paragraph">
<p>Often your want to import hierachical modules. Here&#8217;s how:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Calculator.Area do
...(1)&gt;   def square(a) do
...(1)&gt;     a * a
...(1)&gt;   end
...(1)&gt; end
{:module, Calculator.Area,
 &lt;&lt;70, 79, 82, 49, 0, 0, 4, 232, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 138,
   0, 0, 0, 14, 22, 69, 108, 105, 120, 105, 114, 46, 67, 97, 108, 99, 117, 108,
   97, 116, 111, 114, 46, 65, 114, 101, 97, ...&gt;&gt;, {:square, 1}}
iex(2)&gt; import Calculator.Area
Calculator.Area
iex(3)&gt; square(5)
25</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_alias"><a class="anchor" href="#_alias"></a>Alias</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p><code>alias</code> offers the possiblity to set an alias to a module name.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Calculator.Area do
...(1)&gt;   def square(a) do
...(1)&gt;     a * a
...(1)&gt;   end
...(1)&gt; end
{:module, Calculator.Area,
 &lt;&lt;70, 79, 82, 49, 0, 0, 4, 232, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 138,
   0, 0, 0, 14, 22, 69, 108, 105, 120, 105, 114, 46, 67, 97, 108, 99, 117, 108,
   97, 116, 111, 114, 46, 65, 114, 101, 97, ...&gt;&gt;, {:square, 1}}
iex(2)&gt; alias Calculator.Area, as: Area <i class="conum" data-value="1"></i><b>(1)</b>
Calculator.Area
iex(3)&gt; Area.square(99)
9801
iex(4)&gt; alias Calculator.Area <i class="conum" data-value="2"></i><b>(2)</b>
Calculator.Area
iex(5)&gt; Area.square(99)
9801</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set an alias for <code>Calculator.Area</code> as <code>Area</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A shortcurt for that specific case. Same result but less to type.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_the_pipe_operator"><a class="anchor" href="#_the_pipe_operator"></a>The Pipe Operator (|&gt;)</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Quite often one wants to chain a couple of different functions in a row. Let&#8217;s
assume you want to reverse a string with <code>String.reverse/1</code> and capitalize it
with <code>String.capitalize/1</code> afterwards. Here&#8217;s the code to do that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; String.reverse("house") <i class="conum" data-value="1"></i><b>(1)</b>
"esuoh"
iex(2)&gt; String.capitalize("esuoh") <i class="conum" data-value="2"></i><b>(2)</b>
"Esuoh"
iex(3)&gt; String.capitalize(String.reverse("house")) <i class="conum" data-value="3"></i><b>(3)</b>
"Esuoh"</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>String.reverse/1</code> reverses the string.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>String.capitalize/1</code> capitalizes all the letters in a string.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Connect the two functions.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The problem with <code>String.capitalize(String.reverse("house"))</code> is the lack of
readability. It kind of works with just two functions but what about one or two
more functions in that line? Here comes the pipe operator <code>|&gt;</code> for the rescue.
It is a piece of syntactic sugar. Have a look:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(4)&gt; String.reverse("house") |&gt; String.capitalize <i class="conum" data-value="1"></i><b>(1)</b>
"Esuoh"</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The pipe operator <code>|&gt;</code> takes the result of the first function
and puts it as the first parameter of the following function.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Of course you can use multiple pipe operators:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(5)&gt; String.reverse("house") |&gt; String.capitalize |&gt; String.downcase
"esuoh"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pipe operator is just a way to make code more readable.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lists_and_tuples"><a class="anchor" href="#_lists_and_tuples"></a>Lists and Tuples</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Lists and tuples are used to store multiple elements in a sort of list. Both
look alike but are quite different performance wise.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Tuples are fast when you have to access it&#8217;s data but slow when you want to
change it&#8217;s data. They are stored contiguously in memory. Accessing one
element of a tuple or getting the size of it is fast and always takes the same
amount of time.</p>
</li>
<li>
<p>Lists are stored as linked lists in memory. One element holds it&#8217;s own value
and a link to the next element. Accessing single elements and the length of a
lists is a linear operation which takes more time. The longer the list the
more time it takes. But it is fast to add a new element to the end of a list.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Right now you don&#8217;t need to loose sleep over the decision which one to
use. Over the course of the book you&#8217;ll get a feeling which one is best suited
for what problem.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_lists"><a class="anchor" href="#_lists"></a>Lists</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>List store multiple values or different types.
A list is encapsuled in <code>[]</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; [1, 2, 3, 4]
[1, 2, 3, 4]
iex(2)&gt; ["a", "b", "c"]
["a", "b", "c"]
iex(3)&gt; [1, "b", true, false, :blue, "house"]
[1, "b", true, false, :blue, "house"]
iex(4)&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The operators <code>++</code> and <code>--</code> can be used to concatenate and substract lists from each other:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; [1, 2] ++ [2, 4] <i class="conum" data-value="1"></i><b>(1)</b>
[1, 2, 2, 4]
iex(2)&gt; [1, 2] ++ [1] <i class="conum" data-value="2"></i><b>(2)</b>
[1, 2, 1]
iex(3)&gt; [1, "a", 2, false, true] -- ["a", 2] <i class="conum" data-value="3"></i><b>(3)</b>
[1, false, true]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Makes totally sense.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>So does this.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A bit trickier. The second and third element of the first list get substracted.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_head_and_tail_of_lists"><a class="anchor" href="#_head_and_tail_of_lists"></a>Head and Tail of Lists</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>A lot of times Elixir developers want to work with the head and tail of a list. Head
is the first element (counting from the left side) and the tail is the rest. There
are too functions for that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; shopping_list = ["apple", "orange", "banana", "pineapple"] <i class="conum" data-value="1"></i><b>(1)</b>
["apple", "orange", "banana", "pineapple"]
iex(2)&gt; hd(shopping_list) <i class="conum" data-value="2"></i><b>(2)</b>
"apple"
iex(3)&gt; tl(shopping_list) <i class="conum" data-value="3"></i><b>(3)</b>
["orange", "banana", "pineapple"]
iex(4)&gt; shopping_list <i class="conum" data-value="4"></i><b>(4)</b>
["apple", "orange", "banana", "pineapple"]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We define a list and bind it to the variable <code>shopping_list</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>hd/1</code> fetches the first element of the list.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>tl/1</code> fetches the rest of the list.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>shopping_list</code> itself hasn&#8217;t changed.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s see what happens with empty lists or lists which just have one element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(6)&gt; hd([]) <i class="conum" data-value="1"></i><b>(1)</b>
** (ArgumentError) argument error
    :erlang.hd([])
iex(6)&gt; tl([]) <i class="conum" data-value="2"></i><b>(2)</b>
** (ArgumentError) argument error
    :erlang.tl([])
iex(6)&gt; hd(["grapefruit"]) <i class="conum" data-value="3"></i><b>(3)</b>
"grapefruit"
iex(7)&gt; tl(["grapefruit"]) <i class="conum" data-value="4"></i><b>(4)</b>
[]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You can&#8217;t get the head of an empty list.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>And there is no tail of an empty list.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>There is a head of a list with one element.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The tail of a list with one element is an empty list.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_length1"><a class="anchor" href="#_length1"></a>length/1</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>The function <code>length/1</code> tells how many elements a list contains:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex(2)&gt; length(shopping_list)
4
iex(3)&gt; length([1, 2])
2
iex(4)&gt; length([])
0</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tuples"><a class="anchor" href="#_tuples"></a>Tuples</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Like Lists tuples can hold multiple elements of different types. The
elements are encapsuled with '{}':</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; {1, 2, 3} <i class="conum" data-value="1"></i><b>(1)</b>
{1, 2, 3}
iex(2)&gt; {:ok, "test"} <i class="conum" data-value="2"></i><b>(2)</b>
{:ok, "test"}
iex(3)&gt; {true, :apple, 234, "house", 3.14} <i class="conum" data-value="3"></i><b>(3)</b>
{true, :apple, 234, "house", 3.14}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A tuple which contains three integers.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A tuple which contains one atom which represents a status and one string.
Is is actually something very common in Elixir. You will see that a lot.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A tuple with a mix of all sorts of values.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We don&#8217;t use the head and tail idea with tuples. But we can access every element
of a tuple with an index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; result = {:ok, "Lorem ipsum"}
{:ok, "Lorem ipsum"}
iex(2)&gt; elem(result, 1) <i class="conum" data-value="1"></i><b>(1)</b>
"Lorem ipsum"
iex(3)&gt; elem(result, 0) <i class="conum" data-value="2"></i><b>(2)</b>
:ok</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The function <code>elem/2</code> gives us a fast access to each element of a tuple.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The count starts with 0 for the first element.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_tuple_functions"><a class="anchor" href="#_tuple_functions"></a>Tuple Functions</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>The following functions are useful when you handle data with tuples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Tuple.append/2</code> adds an element to a tuple.
</p>
</li>
<li>
<p><code>Tuple.delete_at/2</code> deletes an element of a tuple.
</p>
</li>
<li>
<p><code>Tuple.insert_at/3</code> adds an element at a specific position.
</p>
</li>
<li>
<p><code>Tuple.to_list/1</code> converts a tuple to a list.
</p>
</li>
<li>
<p><code>Tuple.size/1</code> returns the number of elements of the tuple.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; results = {:ok, "Lorem ipsum"}
{:ok, "Lorem ipsum"}
iex(2)&gt; b = Tuple.append(results, "Test")
{:ok, "Lorem ipsum", "Test"}
iex(3)&gt; c = Tuple.delete_at(b, 1)
{:ok, "Test"}
iex(4)&gt; d = Tuple.insert_at(b, 1, "ipsum")
{:ok, "ipsum", "Lorem ipsum", "Test"}
iex(5)&gt; new_list = Tuple.to_list(d)
[:ok, "ipsum", "Lorem ipsum", "Test"]
iex(6)&gt; tuple_size(d)
4</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_maps_and_structs"><a class="anchor" href="#_maps_and_structs"></a>Maps and Structs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>List and Tuples don&#8217;t provide a functionality to access values with a key.
That can be achieved with Maps and Structs.</p>
</div>
<div class="sect2">
<h3 id="_maps"><a class="anchor" href="#_maps"></a>Maps</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Maps provide a way to store and retrieve key-value pairs. A Map is created
with a <code>%{}</code> syntax.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; product_prices = %{"Apple" =&gt; 0.5, "Orange" =&gt; 0.7} <i class="conum" data-value="1"></i><b>(1)</b>
%{"Apple" =&gt; 0.5, "Orange" =&gt; 0.7}
iex(2)&gt; Map.get(product_prices, "Orange") <i class="conum" data-value="2"></i><b>(2)</b>
0.7
iex(3)&gt; Map.get(product_prices, "Banana") <i class="conum" data-value="3"></i><b>(3)</b>
nil
iex(4)&gt; Map.has_key?(product_prices, "Banana") <i class="conum" data-value="4"></i><b>(4)</b>
false</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We create a new map and bind it to the variable <code>product_prices</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>Map.get/2</code> gets a value to a given key.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>Map.get/2</code> returns nil if a given key doesn&#8217;t exist.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>If you need to check if a key exists you can do it with <code>Map.hay_key?/2</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>But keys don&#8217;t have to be a specific type. Everything can be a key and a value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; %{"one" =&gt; 1, "two" =&gt; "abc", 3 =&gt; 7, true =&gt; "asdf"} <i class="conum" data-value="1"></i><b>(1)</b>
%{3 =&gt; 7, true =&gt; "asdf", "one" =&gt; 1, "two" =&gt; "abc"}
iex(2)&gt; %{"one" =&gt; 1, true =&gt; "asdf", true =&gt; "z"} <i class="conum" data-value="2"></i><b>(2)</b>
warning: key true will be overridden in map
  iex:2

%{true =&gt; "z", "one" =&gt; 1}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A mixed bag of different types. Feel free to go wild.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A key has to be unique within a Map. The last one will be the winner.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_atom_keys"><a class="anchor" href="#_atom_keys"></a>Atom keys</h4>
<div class="paragraph">
<p>Using Atoms as keys in Maps gives you access to some nifty features:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; product_prices = %{apple: 0.5, orange: 0.7} <i class="conum" data-value="1"></i><b>(1)</b>
%{apple: 0.5, orange: 0.7}
iex(2)&gt; product_prices.apple <i class="conum" data-value="2"></i><b>(2)</b>
0.5
iex(3)&gt; product_prices.banana <i class="conum" data-value="3"></i><b>(3)</b>
** (KeyError) key :banana not found in: %{apple: 0.5, orange: 0.7}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>With Atoms as keys you can use this syntax which is a bit easier to read and less work to type.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Again, this syntax is easier to work with but only works for Atom keys.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Just checking what happens if the key doesn&#8217;t exist in the Map.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_map_functions"><a class="anchor" href="#_map_functions"></a>Map Functions</h4>
<div class="paragraph">
<p>The Map module offers a bunch of useful functions. For a complete list have a
look at <a href="https://hexdocs.pm/elixir/Map.html" class="bare">https://hexdocs.pm/elixir/Map.html</a></p>
</div>
<div class="paragraph">
<p>Here are just a couple of examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; product_prices = %{apple: 0.5, orange: 0.7, coconut: 1}
%{apple: 0.5, coconut: 1, orange: 0.7}
iex(2)&gt; Map.to_list(product_prices) <i class="conum" data-value="1"></i><b>(1)</b>
[apple: 0.5, coconut: 1, orange: 0.7]
iex(3)&gt; Map.values(product_prices) <i class="conum" data-value="2"></i><b>(2)</b>
[0.5, 1, 0.7]
iex(4)&gt; Map.split(product_prices, [:orange, :apple]) <i class="conum" data-value="3"></i><b>(3)</b>
{%{apple: 0.5, orange: 0.7}, %{coconut: 1}}
iex(5)&gt; a = Map.delete(product_prices, :orange) <i class="conum" data-value="4"></i><b>(4)</b>
%{apple: 0.5, coconut: 1}
iex(6)&gt; b = Map.drop(product_prices, [:apple, :organge]) <i class="conum" data-value="5"></i><b>(5)</b>
%{coconut: 1, orange: 0.7}
iex(7)&gt; additional_prices = %{banana: 0.4, pineapple: 1.2}
%{banana: 0.4, pineapple: 1.2}
iex(8)&gt; Map.merge(product_prices, additional_prices) <i class="conum" data-value="6"></i><b>(6)</b>
%{apple: 0.5, banana: 0.4, coconut: 1, orange: 0.7, pineapple: 1.2}
iex(9)&gt; c = Map.put(product_prices, :potato, 0.2) <i class="conum" data-value="7"></i><b>(7)</b>
%{apple: 0.5, coconut: 1, orange: 0.7, potato: 0.2}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Map.to_list/1</code> converts a Map into a List.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>Map.values/1</code> returns the values of a Map.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>Map.split/2</code> splits a given map into two new maps. The first one contains all the key-value pairs which are requested by a list (e.g. <code>[:orange, :apple]</code>)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>Map.delete/2</code> deletes a specific key-value pair in a Map.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>Map.drop/2</code> deletes a list of key-value pairs in a Map.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><code>Map.merge/2</code> merges two Maps.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td><code>Map.put/2</code> adds a key-value pair to a Map.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_structs"><a class="anchor" href="#_structs"></a>Structs</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>A Struct is a fancy Map with a couple of extra features. To define a
Struct you have to use the <code>defstruct</code> construct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Product do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;   defstruct name: nil, price: 0 <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt; end
{:module, Product,
 &lt;&lt;70, 79, 82, 49, 0, 0, 6, 192, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 184,
   0, 0, 0, 18, 14, 69, 108, 105, 120, 105, 114, 46, 80, 114, 111, 100, 117, 99,
   116, 8, 95, 95, 105, 110, 102, 111, 95, ...&gt;&gt;, %Product{name: nil, price: 0}}
iex(2)&gt; %Product{}
%Product{name: nil, price: 0}
iex(3)&gt; apple = %Product{name: "Apple", price: 0.5} <i class="conum" data-value="3"></i><b>(3)</b>
%Product{name: "Apple", price: 0.5}
iex(4)&gt; apple
%Product{name: "Apple", price: 0.5}
iex(5)&gt; apple.price
0.5</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We define a new Struct with the name <code>Product</code> and the keys <code>name</code> and <code>price</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We define default values.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We define a new Product Struct and set all values.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A Struct guarantees that only the defined fields are allowed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(6)&gt; apple.description <i class="conum" data-value="1"></i><b>(1)</b>
** (KeyError) key :description not found in: %Product{name: "Apple", price: 0.5}

iex(6)&gt; banana = %Product{name: "Banana", weight: 0.1} <i class="conum" data-value="2"></i><b>(2)</b>
** (KeyError) key :weight not found
    expanding struct: Product.__struct__/1
    iex:6: (file)
iex(6)&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Since we didn&#8217;t define a <code>description</code> field in the Struct we can not access it.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Same with a new Struct. There is no <code>weight</code> field defined. Therefor we can not set it.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Because Struct build on top of Maps they can be used with the same mechanisms.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pattern_matching"><a class="anchor" href="#_pattern_matching"></a>Pattern Matching</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Pattern matching is super important in Elixir and we already used it without
knowing so for binding values to variables.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; a = 10 <i class="conum" data-value="1"></i><b>(1)</b>
10
iex(2)&gt; a
10
iex(3)&gt; {b, c} = {10, 15} <i class="conum" data-value="2"></i><b>(2)</b>
{10, 15}
iex(4)&gt; b
10
iex(5)&gt; c
15
iex(6)&gt; {d, e} = 100
** (MatchError) no match of right hand side value: 100 <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is actually a pattern match. The left side of <code>=</code> will be matched to the right site if possible.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here we pattern match <code>{b, c}</code> on the left side with a tuple on the right side.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Boom! Because we can not match the <code>{d, e}</code> tuple with an integer we get a <code>MatchError</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since we don&#8217;t have much time I&#8217;ll fast forward to match a head and tail of a
list. Because there is a special syntax for that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; shopping_list = ["apple", "orange", "banana", "pineapple"] <i class="conum" data-value="1"></i><b>(1)</b>
["apple", "orange", "banana", "pineapple"]
iex(2)&gt; [head | tail] = shopping_list <i class="conum" data-value="2"></i><b>(2)</b>
["apple", "orange", "banana", "pineapple"]
iex(3)&gt; head
"apple"
iex(4)&gt; tail
["orange", "banana", "pineapple"]
iex(5)&gt; [a | b] = tail <i class="conum" data-value="3"></i><b>(3)</b>
["orange", "banana", "pineapple"]
iex(6)&gt; a
"orange"
iex(7)&gt; b
["banana", "pineapple"]
iex(8)&gt; [first_product, second_product | tail] = shopping_list <i class="conum" data-value="4"></i><b>(4)</b>
["apple", "orange", "banana", "pineapple"]
iex(9)&gt; first_product
"apple"
iex(10)&gt; second_product
"orange"
iex(11)&gt; tail
["banana", "pineapple"]
iex(12)&gt; [first_product | [second_product | tail]] = shopping_list <i class="conum" data-value="5"></i><b>(5)</b>
["apple", "orange", "banana", "pineapple"]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We match a list to the variable <code>shopping_list</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>[head|tail]</code> is the special syntax to match a head and tail of a given list.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Again we match the head <code>a</code> and the tail <code>b</code> with <code>tail</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>A bit more complex. We match agains the first and second product followed by a tail.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Same result. Different syntax and logic. Pick the one you prefer.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Of course if we now that a list has a specific number of elements we can match
it directly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex(2)&gt; [a, b, c, d] = shopping_list
["apple", "orange", "banana", "pineapple"]
iex(3)&gt; a
"apple"
iex(4)&gt; b
"orange"
iex(5)&gt; [e, f, g] = shopping_list <i class="conum" data-value="1"></i><b>(1)</b>
** (MatchError) no match of right hand side value: ["apple", "orange", "banana", "pineapple"]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Just checking. You get an <code>MatchError</code> if Elixir can&#8217;t match both sides.</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_matching_maps"><a class="anchor" href="#_matching_maps"></a>Matching Maps</h3>
<div class="paragraph">
<p>Matching a Map works a little bit different to matching a Tuple or List.
You can match just against the values you are interested in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; product_prices = %{apple: 0.5, orange: 0.7, pineapple: 1}
%{apple: 0.5, orange: 0.7, pineapple: 1}
iex(2)&gt; %{orange: price} = product_prices <i class="conum" data-value="1"></i><b>(1)</b>
%{apple: 0.5, orange: 0.7, pineapple: 1}
iex(3)&gt; price
0.7
iex(4)&gt; %{orange: price1, apple: price2} = product_prices <i class="conum" data-value="2"></i><b>(2)</b>
%{apple: 0.5, orange: 0.7, pineapple: 1}
iex(5)&gt; price1
0.7
iex(6)&gt; price2
0.5</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We can just match one value.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Or we can match multiples. But we don&#8217;t have to match the whole Map.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_matching_stringparts"><a class="anchor" href="#_matching_stringparts"></a>Matching Stringparts</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Easiest explained with a code example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; user = "Stefan Wintermeyer"
"Stefan Wintermeyer"
iex(2)&gt; "Stefan " &lt;&gt; last_name = user
"Stefan Wintermeyer"
iex(3)&gt; last_name
"Wintermeyer"</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The left side of a <code>&lt;&gt;</code> operator in a match should always be a string.
Otherwise Elixir can&#8217;t verify it&#8217;s size.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_wildcard_matching"><a class="anchor" href="#_wildcard_matching"></a>Wildcard Matching</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Sometimes you need the pattern matching to get a value but you don&#8217;t need all
the potential values in the pattern. For those cases you can use <code>_</code> (alone or
as a prefix to a variable name). It indicates to Elixir, das you don&#8217;t need that
to be bind to anything.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex(2)&gt; [first_product | _tail] = shopping_list <i class="conum" data-value="1"></i><b>(1)</b>
["apple", "orange", "banana", "pineapple"]
iex(3)&gt; first_product
"apple"
iex(4)&gt; tail <i class="conum" data-value="2"></i><b>(2)</b>
** (CompileError) iex:4: undefined function tail/0

iex(4)&gt; [head | _] = shopping_list <i class="conum" data-value="3"></i><b>(3)</b>
["apple", "orange", "banana", "pineapple"]
iex(5)&gt; head
"apple"</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We pattern match the head of <code>shopping_list</code> to <code>first_product</code>. But we don&#8217;t need the tail and indicate that by prefix it with a <code>_</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Just double-checking. No, it is not there.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We can use just a <code>_</code> too. Using <code>_tail</code> just improves a bit the code readablity.
So everybody knows that we don&#8217;t need that value but can guess what it would be.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_matching_against_a_variable"><a class="anchor" href="#_matching_against_a_variable"></a>Matching against a variable</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Assuming I&#8217;d like to fetch the second product of a shopping_list list but only if the first product is
an <code>organge</code>. I could do this like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex(2)&gt; ["apple", second_product | _tail] = shopping_list <i class="conum" data-value="1"></i><b>(1)</b>
["apple", "orange", "banana", "pineapple"]
iex(3)&gt; second_product
"orange"
iex(4)&gt; ["potato", second_product | _tail] = shopping_list <i class="conum" data-value="2"></i><b>(2)</b>
** (MatchError) no match of right hand side value: ["apple", "orange", "banana", "pineapple"]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Is this cool or not!?</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Just checking what happens if it doesn&#8217;t match. <code>MatchError</code> is a good indicator for a missmatch.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>But let&#8217;s now assume that you want to match the first product against the content of the variable
<code>first_product</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex(2)&gt; product = "potato" <i class="conum" data-value="1"></i><b>(1)</b>
"potato"
iex(3)&gt; [product, second_product | _tail] = shopping_list <i class="conum" data-value="2"></i><b>(2)</b>
["apple", "orange", "banana", "pineapple"]
iex(4)&gt; product
"apple"
iex(5)&gt; second_product
"orange"
iex(6)&gt; product = "potato" <i class="conum" data-value="3"></i><b>(3)</b>
"potato"
iex(7)&gt; [^product, second_product | _tail] = shopping_list <i class="conum" data-value="4"></i><b>(4)</b>
** (MatchError) no match of right hand side value: ["apple", "orange", "banana", "pineapple"]

iex(7)&gt; product = "apple" <i class="conum" data-value="5"></i><b>(5)</b>
"apple"
iex(8)&gt; [^product, second_product | _tail] = shopping_list <i class="conum" data-value="6"></i><b>(6)</b>
["apple", "orange", "banana", "pineapple"]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We bind the string <code>potato</code> to the variable <code>product</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Now we try to match <code>[product, second_product | _tail]</code> to <code>shopping_list</code>.
That should result in an <code>MatchError</code> because <code>product</code> represents <code>potato</code>.
But no <code>MatchError</code>. Because Elixir doesn&#8217;t know that you want to actually use the bound
value of <code>product</code>. It thinks that you want to bind the first element of the list to the
variable <code>product</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Let&#8217;s try it again.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>To match against the content of <code>product</code> we have to prefix it with a <code>^</code>. By doing
so we get a <code>MatchError</code> because it doesn&#8217;t match.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Let&#8217;s bind "apple" to <code>product</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Bingo! Now we got a working pattern match against a variable.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_pattern_matching_with_functions"><a class="anchor" href="#_pattern_matching_with_functions"></a>Pattern Matching with Functions</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Pattern matching is used everywhere in Elixir. You can even use it with Functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Area do
...(1)&gt;   def circle(:exact, radius) do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;     3.14159265359 * radius * radius
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def circle(:normal, radius) do <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;     3.14 * radius * radius
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def circle(radius) do <i class="conum" data-value="3"></i><b>(3)</b>
...(1)&gt;     circle(:normal, radius)
...(1)&gt;   end
...(1)&gt; end
{:module, Area,
 &lt;&lt;70, 79, 82, 49, 0, 0, 6, 40, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 138,
   0, 0, 0, 15, 11, 69, 108, 105, 120, 105, 114, 46, 65, 114, 101, 97, 8, 95,
   95, 105, 110, 102, 111, 95, 95, 7, 99, ...&gt;&gt;, {:circle, 1}}
iex(2)&gt; Area.circle(:exact, 4)
50.26548245744
iex(3)&gt; Area.circle(:normal, 4)
50.24
iex(4)&gt; Area.circle(4)
50.24</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We define a <code>circle/2</code> function which matches if the first argument is the atom <code>:exact</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We define a <code>circle/2</code> function which matches if the first argument is the atom <code>:normal</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We define a <code>circle/1</code> function which calls the <code>cirle/2</code> function with the <code>:normal</code> argument.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_functions_with_guards"><a class="anchor" href="#_functions_with_guards"></a>Functions with Guards</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Guards add some additional spices to pattern matching with functions. You can find
all the details at <a href="https://hexdocs.pm/elixir/guards.html" class="bare">https://hexdocs.pm/elixir/guards.html</a></p>
</div>
<div class="paragraph">
<p>Here are just some examples to show you the concept. Guards start with <code>when</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Law do
...(1)&gt;   def can_vote?(age) when is_integer(age) and age &gt; 17 do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;     true
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def can_vote?(age) when is_integer(age) do <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;     false
...(1)&gt;   end
...(1)&gt; end
{:module, Law,
 &lt;&lt;70, 79, 82, 49, 0, 0, 5, 32, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 138,
   0, 0, 0, 15, 10, 69, 108, 105, 120, 105, 114, 46, 76, 97, 119, 8, 95, 95,
   105, 110, 102, 111, 95, 95, 7, 99, 111, ...&gt;&gt;, {:can_vote?, 1}}
iex(2)&gt; Law.can_vote?(15)
false
iex(3)&gt; Law.can_vote?(20)
true
iex(4)&gt; Law.can_vote?("test") <i class="conum" data-value="3"></i><b>(3)</b>
** (FunctionClauseError) no function clause matching in Law.can_vote?/1

    The following arguments were given to Law.can_vote?/1:

        # 1
        "test"

    iex:2: Law.can_vote?/1</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This guard checks if the <code>age</code> argument is an integer and the value of it is bigger than 17.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This guard just checks if the <code>age</code> argument is an integer.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Since <code>"test"</code> is a string and not an integer no function matches this.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sometimes it is useful to have a catch all at the end:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule GuardExample do
...(1)&gt;   def is_a_number?(value) when is_integer(value) or is_float(value) do
...(1)&gt;     true
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def is_a_number?(_value) do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;     false
...(1)&gt;   end
...(1)&gt; end
{:module, GuardExample,
 &lt;&lt;70, 79, 82, 49, 0, 0, 5, 56, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 150,
   0, 0, 0, 15, 19, 69, 108, 105, 120, 105, 114, 46, 71, 117, 97, 114, 100, 69,
   120, 97, 109, 112, 108, 101, 8, 95, 95, ...&gt;&gt;, {:is_a_number?, 1}}
iex(2)&gt; GuardExample.is_a_number?(3)
true
iex(3)&gt; GuardExample.is_a_number?(3.14)
true
iex(4)&gt; GuardExample.is_a_number?("one")
false</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>_value</code> catches everything that was not caught by the first <code>is_a_number?/1</code> definition.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_case"><a class="anchor" href="#_case"></a>Case</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p><code>case</code> is a controll structure which matches a given value to a couple of
matching cases until one matches.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume we want to create a function that converts morse coded
numbers to integers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Morse do
...(1)&gt;   def morse_to_number(input) do
...(1)&gt;     case input do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;       "-----" -&gt; 0 <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;       ".----" -&gt; 1
...(1)&gt;       "..---" -&gt; 2
...(1)&gt;       "...--" -&gt; 3
...(1)&gt;       "....-" -&gt; 4
...(1)&gt;       "....." -&gt; 5
...(1)&gt;       "-...." -&gt; 6
...(1)&gt;       "--..." -&gt; 7
...(1)&gt;       "---.." -&gt; 8
...(1)&gt;       "----." -&gt; 9
...(1)&gt;       _ -&gt; :error <i class="conum" data-value="3"></i><b>(3)</b>
...(1)&gt;     end
...(1)&gt;   end
...(1)&gt; end
{:module, Morse,
 &lt;&lt;70, 79, 82, 49, 0, 0, 6, 240, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 141,
   0, 0, 0, 14, 12, 69, 108, 105, 120, 105, 114, 46, 77, 111, 114, 115, 101, 8,
   95, 95, 105, 110, 102, 111, 95, 95, 7, ...&gt;&gt;, {:morse_to_number, 1}}
iex(2)&gt; Morse.morse_to_number("-....") <i class="conum" data-value="4"></i><b>(4)</b>
6</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>After <code>case</code> comes the value we want to check.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>"-----"</code> is the expression we want to match to return a 0.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>_</code> is the catch all in case nothing matched yet. In this case return an <code>:error</code> atom.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>It works. :-)</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Of course we could solve this problem just with functions too. It&#8217;s up to you
what makes most sense in a given situation.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_if_and_unless"><a class="anchor" href="#_if_and_unless"></a>if and unless</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p><code>if</code> and <code>unless</code> are the classics in any programming language. The following
examples will show how to use them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; if 1 == 1 do
...(1)&gt;   "Bingo!"
...(1)&gt; else
...(1)&gt;   "Negative"
...(1)&gt; end
"Bingo!"
iex(2)&gt; unless true do
...(2)&gt;   "Never"
...(2)&gt; end
nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes you see a one line short form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(3)&gt; if 1 == 1, do: "Bingo!"
"Bingo!"</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Most Elixir developers prefer <code>case</code> over <code>if</code> or <code>unless</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_immutability"><a class="anchor" href="#_immutability"></a>Immutability</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Probably you have already heard about immutability in Elixir. What&#8217;s that about?</p>
</div>
<div class="paragraph">
<p>A variable points to a specific part of the memory where the data is stored. In
many programming languages that data can be changed to update a variable. In
Elixir it can not be changed. So that doesn&#8217;t mean that you can&#8217;t rebind a
variable to a different value but that this new value gets a new piece of memory
and doesn&#8217;t overwrite the old memory. Once a function returns a result and
therefor has finished it&#8217;s work everything gets garbage collected (wiped blank).</p>
</div>
<div class="paragraph">
<p>Why is that important at all? With immutable variables we can be absolutly sure
that other processes can not change their values while running parallel tasks.
That has a massive effect. At the end it means that your Phoenix application can
run on multiple CPUs on the same server in parallel. It even means that your
Phoenix application can share multiple CPUs on serveral nodes of a
server-cluster in your data center. It makes Elixir extremly scalable and save.</p>
</div>
<div class="paragraph">
<p>But doesn&#8217;t that make your application slower? Funny thing: No. This way is
actually faster. It is not efficiant to change data in memory.</p>
</div>
<div class="paragraph">
<p>But don&#8217;t worry. It is not as complicated as it sounds. Everytime you use a
variable it uses the value of that moment in time. It will not be effected/changed
afterwords:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; product = "Orange"
"Orange"
iex(2)&gt; test1 = fn -&gt; IO.puts(product) end <i class="conum" data-value="1"></i><b>(1)</b>
#Function&lt;21.126501267/0 in :erl_eval.expr/5&gt;
iex(3)&gt; product = "Apple"
"Apple"
iex(4)&gt; test2 = fn -&gt; IO.puts(product) end
#Function&lt;21.126501267/0 in :erl_eval.expr/5&gt;
iex(5)&gt; product = "Pineapple"
"Pineapple"
iex(6)&gt; test3 = fn -&gt; IO.puts(product) end
#Function&lt;21.126501267/0 in :erl_eval.expr/5&gt;
iex(7)&gt; product = "Banana"
"Banana"
iex(8)&gt; test1.() <i class="conum" data-value="2"></i><b>(2)</b>
Orange
:ok
iex(9)&gt; test2.()
Apple
:ok
iex(10)&gt; test3.()
Pineapple
:ok
iex(11)&gt; IO.puts(product)
Banana
:ok</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Those anonymous functions may run on totally different CPUs. The life in their own little universe.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The value of <code>product</code> has changed multiple times. But for <code>test1.()</code> it is the value from that point in time when we created the function.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sigils"><a class="anchor" href="#_sigils"></a>Sigils</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Until now encapsulated Strings in double quotes and we haven&#8217;t talked about char
lists at all (IMO not needed for a beginners introduction). But there is one more
mechanism to represent texts. They are called <code>Sigils</code> and start with a <code>~</code> (tilde)
character which is followed by on letter which indicates what kind of sigil it is.
After that you can use a couple of different delimiters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">~r/example text/
~r|example text|
~r"example text"
~r'example text'
~r(example text)
~r[example text]
~r{example text}
~r&lt;example text&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Elixir provides different delimiters for sigils so that you can write
literals without escaped delimiters.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_regular_expressions"><a class="anchor" href="#_regular_expressions"></a>Regular expressions</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p><code>~r</code> marks a <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expression</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; regex = ~r/bcd/
~r/bcd/
iex(2)&gt; "abcde" =~ regex
true
iex(3)&gt; "efghi" =~ regex
false
iex(4)&gt; regex = ~r/stef/i <i class="conum" data-value="1"></i><b>(1)</b>
~r/stef/i
iex(5)&gt; "Stefan" =~ regex
true</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Modifier are supported too. For a complete list have a look at <a href="https://hexdocs.pm/elixir/Regex.html" class="bare">https://hexdocs.pm/elixir/Regex.html</a></td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_string"><a class="anchor" href="#_string"></a>String</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>You can use the <code>~s</code> sigil to generate a string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; example = ~s(WOW! "double" and 'single' quotes without escaping)
"WOW! \"double\" and 'single' quotes without escaping"
iex(2)&gt; IO.puts(example)
WOW! "double" and 'single' quotes without escaping
:ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sigils support heredocs too. You can use triple double- or single-quotes as separatos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; example_text = ~s"""
...(1)&gt; This is an example text.
...(1)&gt; Multiple lines are not a problem.
...(1)&gt; """
"This is an example text.\nMultiple lines are not a problem.\n"
iex(2)&gt; IO.puts(example_text)
This is an example text.
Multiple lines are not a problem.

:ok</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_word_lists"><a class="anchor" href="#_word_lists"></a>Word lists</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>The <code>~w</code> sigil is a useful way to generate lists of words:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; shopping_cart = ~w(apple orange banana)
["apple", "orange", "banana"]
iex(2)&gt; shopping_cart_atoms = ~w(apple orange banana)a <i class="conum" data-value="1"></i><b>(1)</b>
[:apple, :orange, :banana]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>a</code> modifier tells Elixir to generate a list of atoms and not strings.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_date_and_time"><a class="anchor" href="#_date_and_time"></a>Date and Time</h3>
<div class="paragraph">
<p>Elixir provides a couple of good to go time related Struct[structs] which
all have their own sigil.</p>
</div>
<div class="sect3">
<h4 id="_date"><a class="anchor" href="#_date"></a>Date</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Elixir provides a <code>%Date{}</code> struct that contains the following fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>year</code></p>
</li>
<li>
<p><code>month</code></p>
</li>
<li>
<p><code>day</code></p>
</li>
<li>
<p><code>calendar</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With the <code>~D</code> sigil you can create new <code>%Date{}</code> struct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; birthday = ~D[1973-03-23]
~D[1973-03-23]
iex(2)&gt; birthday.day
23
iex(3)&gt; birthday.month
3
iex(4)&gt; birthday.year
1973</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_time"><a class="anchor" href="#_time"></a>Time</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Elixir provides a <code>%Time{}</code> struct that contains the following fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hour</code></p>
</li>
<li>
<p><code>minute</code></p>
</li>
<li>
<p><code>second</code></p>
</li>
<li>
<p><code>microsecond</code></p>
</li>
<li>
<p><code>calendar</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With the <code>~T</code> sigil you can create new <code>%Time{}</code> struct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; now = ~T[09:29:00.0]
~T[09:29:00.0]
iex(2)&gt; now.hour
9</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_naivedatetime"><a class="anchor" href="#_naivedatetime"></a>NaiveDateTime</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>The <code>%NaiveDateTime{}</code> struct mixes <code>%Date{}</code> with <code>%Time{}</code>.</p>
</div>
<div class="paragraph">
<p>With the <code>~N</code> sigil you can create new <code>%NaiveDateTime{}</code> struct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; timestamp = ~N[2020-05-08 09:48:00]
~N[2020-05-08 09:48:00]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_datetime"><a class="anchor" href="#_datetime"></a>DateTime</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>The <code>%DateTime{}</code> struct adds a timezone to a <code>%NaiveDateTime{}</code>.</p>
</div>
<div class="paragraph">
<p>With the <code>~U</code> sigil you can create new <code>%NaiveDateTime{}</code> struct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(4)&gt; timestamp = ~U[2029-05-08 09:59:03Z]
~U[2029-05-08 09:59:03Z]</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Find more information about timezones and DateTime at <a href="https://hexdocs.pm/elixir/DateTime.html" class="bare">https://hexdocs.pm/elixir/DateTime.html</a>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_recursion"><a class="anchor" href="#_recursion"></a>Recursion</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Recursions are magic and can be a dangerous trap at the same time.
Because of immutability they are more important in Elixir than in
other objectoriented programming languages.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s write a function recursion function which provides a countdown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Example do
...(1)&gt;   def countdown(1) do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;     IO.puts "1" <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def countdown(n) when is_integer(n) and n &gt; 1 do <i class="conum" data-value="3"></i><b>(3)</b>
...(1)&gt;     IO.puts Integer.to_string(n) <i class="conum" data-value="4"></i><b>(4)</b>
...(1)&gt;     countdown(n - 1) <i class="conum" data-value="5"></i><b>(5)</b>
...(1)&gt;   end
...(1)&gt; end
{:module, Example,
 &lt;&lt;70, 79, 82, 49, 0, 0, 5, 188, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 166,
   0, 0, 0, 17, 14, 69, 108, 105, 120, 105, 114, 46, 69, 120, 97, 109, 112, 108,
   101, 8, 95, 95, 105, 110, 102, 111, 95, ...&gt;&gt;, {:countdown, 1}}
iex(2)&gt; Example.countdown(4) <i class="conum" data-value="6"></i><b>(6)</b>
4
3
2
1
:ok</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If <code>countdown/1</code> is called with the argument <code>1</code> this is the best match.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We call <code>IO.puts("1")</code> to print 1 to STDOUT.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If <code>countdown/1</code> is called with an integer bigger than 1 as an argument this function matches.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We either have to use <code>Integer.to_string(n)</code> (we could to a "#{n}" too) to print that integer to STDOUT.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>We recursively decrese <code>n</code> by 1 and call <code>countdown/1</code> with that new number.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>It works!</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here&#8217;s a different example where we calculate the sum of a list of integers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Example do
...(1)&gt;   def sum([]) do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;     0
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def sum([head | tail]) do <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;     head + sum(tail) <i class="conum" data-value="3"></i><b>(3)</b>
...(1)&gt;   end
...(1)&gt; end
{:module, Example,
 &lt;&lt;70, 79, 82, 49, 0, 0, 5, 12, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 127,
   0, 0, 0, 14, 14, 69, 108, 105, 120, 105, 114, 46, 69, 120, 97, 109, 112, 108,
   101, 8, 95, 95, 105, 110, 102, 111, 95, ...&gt;&gt;, {:sum, 1}}
iex(2)&gt; Example.sum([10, 8, 12, 150]) <i class="conum" data-value="4"></i><b>(4)</b>
180
iex(3)&gt; [head | tail] = [150] <i class="conum" data-value="5"></i><b>(5)</b>
[150]
iex(4)&gt; tail
[]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The sum of an empty list is 0.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We pattern match a list and split it into a <code>head</code> and a <code>tail</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We add the current <code>head</code> to the sum of the <code>tail</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>It works!</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This is just to show how Elixir handles the case of a list with one element.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can use the same concept to transform every element of a list. Let&#8217;s assume
we want to double the value of every element of a list:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Example do
...(1)&gt;   def double([]) do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;     []
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def double([head | tail]) do
...(1)&gt;     [head * 2 | double(tail)] <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;   end
...(1)&gt; end
{:module, Example,
 &lt;&lt;70, 79, 82, 49, 0, 0, 5, 40, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 130,
   0, 0, 0, 14, 14, 69, 108, 105, 120, 105, 114, 46, 69, 120, 97, 109, 112, 108,
   101, 8, 95, 95, 105, 110, 102, 111, 95, ...&gt;&gt;, {:double, 1}}
iex(2)&gt; Ex
Example      Exception
iex(2)&gt; Example.double([10, 5, 999])
[20, 10, 1998]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We again start with the most simple match. An empty list. That will result in an empty list.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>[head | tail]</code> syntax works both ways. We can use it to build a list too.</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_how_to_tackle_a_recursion"><a class="anchor" href="#_how_to_tackle_a_recursion"></a>How to tackle a recursion</h3>
<div class="paragraph">
<p>Unless you are doing this every day you will get to problems where you know that a
recursion is a good solution but you just can&#8217;t think of a good recursion for it.</p>
</div>
<div class="paragraph">
<p>Let me share a pro tip for these situations: <a href="https://www.google.com" class="bare">https://www.google.com</a> and
<a href="https://stackoverflow.com" class="bare">https://stackoverflow.com</a> are my life-saver in such situations. No embarrassment!</p>
</div>
<div class="paragraph">
<p>During this book we will work with recursions. So you&#8217;ll get a better feeling for
it.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mix"><a class="anchor" href="#_mix"></a>mix</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>By now you understand the basics of Elixir. The next step is to create an
application. In the Elixir ecosystem this is done with the (already installed)
command-line interface (CLI) <code>mix</code>. Let&#8217;s do that for a "Hello world!"
application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix new hello_world
* creating README.md
* creating .formatter.exs
* creating .gitignore
* creating mix.exs
* creating lib
* creating lib/hello_world.ex
* creating test
* creating test/test_helper.exs
* creating test/hello_world_test.exs

Your Mix project was created successfully.
You can use "mix" to compile it, test it, and more:

    cd hello_world
    mix test

Run "mix help" for more commands.</code></pre>
</div>
</div>
<div class="paragraph">
<p>The command ´mix new projectname` creates a new directory with the name <code>projectname</code>
and fills it with a default structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ cd hello_world
$ tree
.
├── README.md
├── lib
│   └── hello_world.ex
├── mix.exs
└── test
    ├── hello_world_test.exs
    └── test_helper.exs

2 directories, 5 files</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Phoenix directory structure will be more complex but has the same core.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mix_tasks"><a class="anchor" href="#_mix_tasks"></a>mix tasks</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>A task is the mechanism to start code with <code>mix</code>. For our "Hello world!"
programm we have to create the directory <code>lib/mix/tasks</code> and create the file
<code>lib/mix/tasks/start.ex</code> with this code:</p>
</div>
<div class="paragraph">
<p>lib/mix/tasks/start.ex</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule Mix.Tasks.Start do
  use Mix.Task

  def run(_) do <i class="conum" data-value="1"></i><b>(1)</b>
    IO.puts "Hello world!"
  end
end</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>run(_)</code> function is the default function which gets called automatically.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we can start the <code>mix start</code> task:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix start
Compiling 1 file (.ex)
Generated hello_world app
Hello world!</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.ex</code> file gets compiled and the <code>start</code> task gets run. The compile is only
done when needed. If we call <code>mix start</code> a second time no compile is needed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix start
Hello world!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously <code>mix</code> as a topic is much more complex. In this section I just wanted
to show you the very basic idea of mix. So that you know where to search if you
want to know what happens if you do a <code>mix server</code> with a Phoenix application.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mix_format"><a class="anchor" href="#_mix_format"></a>mix format</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>You are going to love <code>mix format</code>. You can call it in the root directory of
your Phoenix application and it will autoformat all your Elixir source code
files.</p>
</div>
<div class="paragraph">
<p>You should use <code>mix format</code> everytime you are going to commit code to a
repository.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_else"><a class="anchor" href="#_what_else"></a>What else?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter just deals with the tip of the iceberg. It provides the basic
knowledge that you need to start with the Phoenix Framework. There is a lot more
to learn. But I wouldn&#8217;t worry too much about that right now. You are good to
go for the next chapter of this book. Have fun!</p>
</div>
<div class="sect2">
<h3 id="_elixir_books"><a class="anchor" href="#_elixir_books"></a>Elixir Books</h3>
<div class="paragraph">
<p>If you want to dive more into Elixir than I recommend the following
books:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://pragprog.com/book/cdc-elixir/learn-functional-programming-with-elixir">Learn Functional Programming with Elixir</a> by Ulisses Almeida ([@ulissesalmeida
](<a href="https://twitter.com/ulissesalmeida)" class="bare">https://twitter.com/ulissesalmeida)</a>)</p>
<div class="paragraph">
<p>In my opinion the best beginners book for Elixir.</p>
</div>
</li>
<li>
<p><a href="https://twitter.com/pragdave)">Programming Elixir 1.6</a>(<a href="https://pragprog.com/book/elixir16/programming-elixir-1-6" class="bare">https://pragprog.com/book/elixir16/programming-elixir-1-6</a>) by Dave Thomas ([@pragdave]</p>
<div class="paragraph">
<p>Dave - as always - wrote a very book book which shines a light into many details.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>Copyright (C) 2020-2020 Stefan Wintermeyer - <a href="https://www.wintermeyer-consulting.de">wintermeyer-consulting.de</a> - Twitter: <a href="https://twitter.com/wintermeyer">@wintermeyer</a></p>
  <p>This webpage was build with <a href="https://antora.org">Antora</a>.</p>
</footer>
<script src="../../antora-assets/js/site.js"></script>
<script async src="../../antora-assets/js/vendor/highlight.js"></script>
  </body>
</html>

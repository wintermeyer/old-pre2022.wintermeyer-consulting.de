<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Elixir Introduction :: Phoenix Beginner&#x27;s Guide</title>
    <link rel="canonical" href="https://www.wintermeyer-consulting.de/books/phoenix/1.5/phoenix/1.5/elixir-introduction.html">
    <meta name="generator" content="Antora 2.3.1">
    <link rel="stylesheet" href="../../antora-assets/css/site.css">
    <link rel="stylesheet" href="../../antora-assets/css/site-extra.css">
  </head>
  <body class="article">
<header class="header" role="banner">
  <nav class="navbar">
    <div class="navbar-brand">
      <div class="navbar-item">
        <a href="/">Wintermeyer Consulting</a>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item has-dropdown is-hoverable">
          <div class="navbar-link">Phoenix Links</div>
          <div class="navbar-dropdown">
            <div class="navbar-item"><strong>Phoenix Framework</strong></div>
            <a class="navbar-item" href="https://www.phoenixframework.org">Phoenix Homepage</a>
            <a class="navbar-item" href="https://github.com/phoenixframework/phoenix">GitHub Repository</a>
            <hr class="navbar-divider">
            <div class="navbar-item"><strong>Elixir</strong></div>
            <a class="navbar-item" href="https://elixir-lang.org">Elixir Homepage</a>
            <a class="navbar-item" href="https://github.com/elixir-lang/elixir">GitHub Repository</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <div class="navbar-link">Stefan Wintermeyer</div>
          <div class="navbar-dropdown">
            <div class="navbar-item"><strong>Work related</strong></div>
            <a class="navbar-item" href="https://www.wintermeyer-consulting.de">Training and Consulting</a>
            <a class="navbar-item"
              href="https://speakerdeck.com/wintermeyer">SpeakerDeck</a>
            <hr class="navbar-divider">
            <div class="navbar-item"><strong>Phoenix projects</strong></div>
            <a class="navbar-item"
              href="https://www.vutuv.de/users/stefan.wintermeyer">vutuv</a>
            <a class="navbar-item"
              href="https://www.mehr-schulferien.de">Schulferien Deutschland</a>
            <div class="navbar-item"><strong>Private</strong></div>
            <a class="navbar-item" href="https://www.wintermeyer.de">Personal Homepage</a>
            <div class="navbar-item"><strong>Social Media</strong></div>
            <a class="navbar-item" href="https://twitter.com/wintermeyer">Twitter</a>
            <a class="navbar-item" href="https://www.facebook.com/stefan.wintermeyer">Facebook</a>
            <a class="navbar-item"
              href="https://www.instagram.com/wintermeyer/">Instagram</a>
          </div>
        </div>
        <a class="navbar-item" href="https://twitter.com/wintermeyer">
          <span class="icon">
            <svg aria-hidden="true" data-icon="twitter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
              <path fill="#57aaee" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path>
            </svg>
          </span>
        </a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="phoenix" data-version="1.5">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">Phoenix Beginner&#x27;s Guide</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index.html#preface">Preface</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="elixir-introduction.html">Elixir Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="phoenix-basics.html">Phoenix Basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-basics.html#the-base-setup">The Base Setup</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-basics.html#hello-world">Hello World!</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="phoenix-basics.html#conn-struct">The conn Struct</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="phoenix-basics.html#static-clock">Static Clock</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-basics.html#links">Links</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="phoenix-basics.html#static-files">Static files</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="phoenix-basics.html#images">Images</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-basics.html#css">CSS</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="phoenix-liveview-basics.html">LiveView Basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-liveview-basics.html#light-switch">Light Switch</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-liveview-basics.html#clock">Clock</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-liveview-basics.html#counter">Counter</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-liveview-basics.html#aiport-code-search">Airport Code Search</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phoenix-liveview-basics.html#autocomplete">Autocomplete</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="router.html">Router</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="router.html#mix-phx-routes">Display all existing routes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="router.html#router-params">Params</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="router.html#router-query-string">Query Strings</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="router.html#router-multilevel-paths">Multilevel Paths</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="router.html#router-wildcards">Wildcards</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="ecto-basics.html">Ecto Basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ecto-basics.html#ecto-create-database">Create a Database</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ecto-basics.html#ecto-create-table">Create a Table</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ecto-basics.html#ecto-create-dataset">Create a Dataset</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="ecto-basics.html#validations">Validations</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="ecto-basics.html#ecto-uniqueness">Uniqueness Validations</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ecto-basics.html#ecto-seeds">Seeds</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ecto-basics.html#ecto-list">Return all Entries of a Table</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ecto-basics.html#ecto-get">Return one Entry of a Table by ID</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index.html#training">Remote Training</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Phoenix Beginner&#x27;s Guide</span>
    <span class="version">1.5</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Phoenix Beginner's Guide</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">1.5</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Phoenix Beginner's Guide</a></li>
    <li><a href="elixir-introduction.html">Elixir Introduction</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="file:///Users/stefan/Github/phoenix-book/modules/ROOT/pages/elixir-introduction.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<article class="doc">
<h1 class="page">Elixir Introduction</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This chapter will teach you the absolute basics of Elixir, just enough for you
to become productive with Phoenix.</p>
</div>
<div class="paragraph">
<p>Buckle up. It is going to be a bumpy and sometimes dull ride. It&#8217;s tough to
teach all the needed Elixir knowledge in just one chapter.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Elixir version</div>
<div class="paragraph">
<p>All code examples are written and tested for Elixir version 1.10.2.
Please make sure that you have that or a higher version installed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ elixir -v
Erlang/OTP 22 [erts-10.6.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Elixir 1.10.2 (compiled with Erlang/OTP 21)</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elixir-introduction-iex"><a class="anchor" href="#elixir-introduction-iex"></a>Elixir&#8217;s Interactive Shell (iex)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Your Elixir installation comes with Elixir&#8217;s Interactive Shell (<code>iex</code>), which
we will use for most of the examples in this chapter. Please go to your command
line and fire it up:
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">$ iex
Erlang/OTP 22 [erts-10.6.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Interactive Elixir (1.10.2) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&gt; <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is your iex prompt.</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You have to press <code>CTRL-C</code> twice (or <code>CTRL-\</code> once) to exit <code>iex</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>iex</code> will be your trusted friend during the work with this book and later
while working with Phoenix. While programming in development mode, you can use
it for diving into the core of your Phoenix application. You can do so too while
being in production mode but that is the equivalent to open-heart surgery. It
can be a lifesaver, but you need to know what you are doing.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
iex offers autocomplete when possible. So when in doubt press <code>TAB</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
iex offers a history too. To access the last command, just press on the
arrow-up key.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_help_in_the_iex_shell"><a class="anchor" href="#_help_in_the_iex_shell"></a>Help in the iex shell</h3>
<div class="paragraph">
<p>iex has a built-in help function <code>h/1</code> which gives you access to some
basic documentation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(2)&gt; h length/1

                                def length(list)

  @spec length(list()) :: non_neg_integer()

guard: true

Returns the length of the list.

Allowed in guard tests. Inlined by the compiler.

# Examples

    iex&gt; length([1, 2, 3, 4, 5, 6, 7, 8, 9])
    9</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elixir-introduction-hello-world"><a class="anchor" href="#elixir-introduction-hello-world"></a>Hello world!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The classic! But never the less very important. You can use the function
<code>IO.puts()</code> to print a string to standard output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; IO.puts("Hello world!")
Hello world!
:ok</code></pre>
</div>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>You should always enclose strings within double quotes. If you use single
quotes, that creates a charlist, which is a different type.</p>
</div>
<div class="paragraph">
<p>In case there are double quotes within a string you have to escape them with
backslashes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(2)&gt; IO.puts("With double quotes: \"Hello world!\"")
With double quotes: "Hello world!"
:ok
iex(3)&gt;
BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution
^C<i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Don&#8217;t be afraid of the <code>BREAK</code> menu. With the first <code>Ctrl+C</code> the <code>iex</code>
displays this list of choices (the <code>BREAK</code> menu) and with the second <code>Ctrl+C</code>
you end the <code>iex</code> session.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elixir-introduction-basic-calculations"><a class="anchor" href="#elixir-introduction-basic-calculations"></a>Basic Calculations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We can use the types <code>integer</code> (integer numbers) and <code>float</code> (real numbers) to
do all sorts of calculations. We can use the usual operators (+, -, etc.). Here
are a few examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">$ iex
Erlang/OTP 22 [erts-10.6.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

Interactive Elixir (1.10.2) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&gt; 1 + 1
2
iex(2)&gt; 1.1 + 1
2.1
iex(3)&gt; 2 - 1
1
iex(4)&gt; 10 * 1000000000000000
10000000000000000
iex(5)&gt; 23 / 3
7.666666666666667</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elixir-introduction-logical-expressions"><a class="anchor" href="#elixir-introduction-logical-expressions"></a>Logical Expressions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A type <code>boolean</code> can store the values <code>true</code> or <code>false</code>. These can be used with
the operators <code>and</code>, <code>or</code> and <code>not</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; true and true
true
iex(2)&gt; false and false
false
iex(3)&gt; true or false
true
iex(4)&gt; not true
false</code></pre>
</div>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>The operators <code>and</code>, <code>or</code> and <code>not</code> can only work with boolean values. The
operators <code>&amp;&amp;</code> (and), <code>||</code> (or) and <code>!</code> (not) do the same but are a bit more
free-spirited and accept <strong>truthy</strong> and <strong>falsy</strong> values (false or nil).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elixir-introduction-variables"><a class="anchor" href="#elixir-introduction-variables"></a>Variables</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>You already know how variables work from experiences in other programming
languages. Therefore we can dive right into it. Variable names follow the
<a href="https://en.wikipedia.org/wiki/Snake_case">snake_case</a> format and start with a
lower case. Some examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; length = 10 <i class="conum" data-value="1"></i><b>(1)</b>
10
iex(2)&gt; width = 23
23
iex(3)&gt; area = length * width
230</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We use the operator <code>=</code> to bind the value 10 to the variable with the name <code>length</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you start a variable name with a capital error you will get an error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(4)&gt; Radius = 2
** (MatchError) no match of right hand side value: 2 <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Yes, <code>MatchError</code> is a rather strange error message here. It will make more
sense later. Binding values to variables is a bit more complicated than it seems
right now.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_modules_and_functions"><a class="anchor" href="#_modules_and_functions"></a>Modules and Functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>So far, we have looked at basic calculations and types in isolation. However, if
we want to create an application, we will need to combine these calculations and
types in a structured way. To see how this is done, we need to look at modules
and functions.</p>
</div>
<div class="paragraph">
<p>In Elixir, code is organized into modules, and each module is a collection of
functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Store do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;   def total_price(price, amount) do <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;     price * amount <i class="conum" data-value="3"></i><b>(3)</b>
...(1)&gt;   end
...(1)&gt; end
{:module, Store,
 &lt;&lt;70, 79, 82, 49, 0, 0, 5, 4, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 133, 0,
   0, 0, 14, 12, 69, 108, 105, 120, 105, 114, 46, 83, 116, 111, 114, 101, 8, 95,
   95, 105, 110, 102, 111, 95, 95, 7, ...&gt;&gt;, {:total_price, 2}} <i class="conum" data-value="4"></i><b>(4)</b>
iex(2)&gt; Store.total_price(10,7) <i class="conum" data-value="5"></i><b>(5)</b>
70</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>defmodule</code> is the keyword to define a module. The name of a module starts with a capital letter.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>def</code> is the keyword to define a function within a module.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The return value of a function is the return value of the last expression in
the function.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The return value of creating the module. To save space, we will abbreviate
this output in the next examples.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A function of a given module can be called from outside the module with this syntax.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>defmodule</code> and <code>def</code> use a <code>do &#8230;&#8203; end</code> construct to begin and end.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Module names use CamelCase starting with a capital letter. Function
names use snake_case.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also define a module in a separate file (with the <code>.exs</code> extension),
and then call the function with <code>iex <em>filename</em>.exs</code>.</p>
</div>
<div class="paragraph">
<p>As an example, save the following module to <code>math.exs</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule Math do
  def sum(x, y) do
    x + y
  end

  def difference(x, y) do
    x - y
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, if you run <code>iex math.exs</code>, you can access the functions in the Math module
in iex.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; Math.sum(1, 2)
3
iex(2)&gt; Math.difference(3, 1)
2</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_private_functions"><a class="anchor" href="#_private_functions"></a>Private Functions</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Sometimes you want to define a function within a module without exposing it to
the outside world. You can do this with a private function which gets declared
with <code>defp</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Area do
...(1)&gt;   def circle(radius) do
...(1)&gt;     pi() * radius * radius
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   defp pi do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;     3.14
...(1)&gt;   end
...(1)&gt; end
{:module, Area, ...
iex(2)&gt; Area.circle(10) <i class="conum" data-value="2"></i><b>(2)</b>
314.0
iex(3)&gt; Area.pi <i class="conum" data-value="3"></i><b>(3)</b>
** (UndefinedFunctionError) function Area.pi/0 is undefined or private
    Area.pi()</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The function <code>pi/0</code> is a private function.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The function <code>circle/1</code> can be called from outside the module. It can use
the private function <code>pi/0</code> from within the module.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The function <code>pi/0</code> can not be called from outside the module.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_function_arity"><a class="anchor" href="#_function_arity"></a>Function Arity</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>In the last couple of sentences, you probably recognized that the names of
functions were followed by the number of parameters. We refer to the <code>pi</code>
function as <code>pi/0</code> and the <code>circle</code> function as <code>circle/1</code>. We call this number
<strong>arity</strong>. Arity is kind of a big thing in Elixir. Why? Because not just the
function name but also the arity defines a function. For example, the
<code>Rectangle</code> module below has two functions with the same name, but different
arity, and so they are treated as different functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Rectangle do
...(1)&gt;   def area(a) do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;     a * a
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def area(a, b) do <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;     a * b
...(1)&gt;   end
...(1)&gt; end
{:module, Rectangle, ...
iex(2)&gt; Rectangle.area(9) <i class="conum" data-value="3"></i><b>(3)</b>
81
iex(3)&gt; Rectangle.area(4, 5) <i class="conum" data-value="4"></i><b>(4)</b>
20</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The function <code>area/1</code> with an arity of 1 accepts one parameter.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The function <code>area/2</code> with an arity of 2 accepts two parameters. This is
essentially a different function from <code>area/1</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>So to calculate the area of a square you can call <code>area/1</code> with just one parameter.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>All non square rectangle areas have to be calculated with <code>area/2</code> which accepts two parameters.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_hierarchical_modules"><a class="anchor" href="#_hierarchical_modules"></a>Hierarchical Modules</h3>
<div class="paragraph">
<p>In a big project, you will have multiple layers of Module namespaces to keep everything in
some sort of structure.</p>
</div>
<div class="paragraph">
<p>This can be done by adding <code>.</code> between the Module names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Calculator.Area do
...(1)&gt;   def square(a) do
...(1)&gt;     a * a
...(1)&gt;   end
...(1)&gt; end
{:module, Calculator.Area, ...
iex(2)&gt; Calculator.Area.square(5)
25</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is just a shortcut. You could also nest the Modules:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Calculator do
...(1)&gt;   defmodule Area do
...(1)&gt;     def square(a) do
...(1)&gt;       a * a
...(1)&gt;     end
...(1)&gt;   end
...(1)&gt; end
{:module, Calculator, ...
iex(2)&gt; Calculator.Area.square(5)
25</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_import"><a class="anchor" href="#_import"></a>Import</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>We can import access to public functions from other modules. So that we don&#8217;t
have to use their fully qualified name.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Rectangle do
...(1)&gt;   def area(a) do
...(1)&gt;     a * a
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def area(a, b) do
...(1)&gt;     a * b
...(1)&gt;   end
...(1)&gt; end
{:module, Rectangle, ...
iex(2)&gt; import Rectangle <i class="conum" data-value="1"></i><b>(1)</b>
Rectangle
iex(3)&gt; area(5) <i class="conum" data-value="2"></i><b>(2)</b>
25</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Here we <code>import Rectangle</code> to have all the functions of that module at our fingertips.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>No need to <code>Rectangle.area/1</code> any more <code>area/1</code> is just fine.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And you can also just import special functions from that module:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(3)&gt; import Rectangle, only: [area: 2] <i class="conum" data-value="1"></i><b>(1)</b>
Rectangle
iex(4)&gt; area(1) <i class="conum" data-value="2"></i><b>(2)</b>
** (CompileError) iex:7: undefined function area/1

iex(7)&gt; area(1,5) <i class="conum" data-value="3"></i><b>(3)</b>
5</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Let&#8217;s just import <code>area/2</code> but not all the other functions of that module.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>I try to run <code>area/1</code>, but that triggered an error because I didn&#8217;t import it.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Just works fine.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Whenever you just use a given function without a module name before it,
that means that the module has already been imported by Elixir (e.g. the
<code>Kernel</code> module gets imported automatically).
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_import_hierarchical_modules"><a class="anchor" href="#_import_hierarchical_modules"></a>Import Hierarchical Modules</h4>
<div class="paragraph">
<p>Often your want to import hierachical modules. Here&#8217;s how:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Calculator.Area do
...(1)&gt;   def square(a) do
...(1)&gt;     a * a
...(1)&gt;   end
...(1)&gt; end
{:module, Calculator.Area, ...
iex(2)&gt; import Calculator.Area
Calculator.Area
iex(3)&gt; square(5)
25</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_alias"><a class="anchor" href="#_alias"></a>Alias</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p><code>alias</code> sets an alias for a module.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Calculator.Area do
...(1)&gt;   def square(a) do
...(1)&gt;     a * a
...(1)&gt;   end
...(1)&gt; end
{:module, Calculator.Area, ...
iex(2)&gt; alias Calculator.Area, as: Area <i class="conum" data-value="1"></i><b>(1)</b>
Calculator.Area
iex(3)&gt; Area.square(99)
9801
iex(4)&gt; alias Calculator.Area <i class="conum" data-value="2"></i><b>(2)</b>
Calculator.Area
iex(5)&gt; Area.square(99)
9801</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set an alias for <code>Calculator.Area</code> as <code>Area</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A shortcurt for that specific case. Same result but less to type.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_use"><a class="anchor" href="#_use"></a>Use</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p><code>use</code> allows a module to inject code into the current module, such as importing
modules, defining new functions, setting a module&#8217;s state, etc.</p>
</div>
<div class="paragraph">
<p>In many of the tests in your Phoenix application, you will see <code>use
ExUnit.Case</code>, which performs certain checks, sets some module attributes and
imports needed modules.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elixir-introduction-atoms"><a class="anchor" href="#elixir-introduction-atoms"></a>Atoms</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An atom is a constant whose name is its value. In some other programming
languages, these are known as symbols. Atoms start with a <code>:</code></p>
</div>
<div class="paragraph">
<p>Atoms are often used to tag values and messages. For example, functions that
might fail often have the return values <code>{:ok, value}</code> or <code>{:error, message}</code>.</p>
</div>
<div class="paragraph">
<p>Atoms are also used to reference modules from Erlang libraries.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; :red
:red
iex(2)&gt; :blue
:blue
iex(3)&gt; is_atom(:blue) <i class="conum" data-value="1"></i><b>(1)</b>
true</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The function <code>is_atom()</code> can be used to check if something is an atom.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You should write atoms in snake_case or CamelCase. The usual Elixir convention is to use snake_case.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elixir-introduction-strings"><a class="anchor" href="#elixir-introduction-strings"></a>Strings</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>We already used a string in the <a href="#elixir-introduction-hello-world">Hello World</a> example.
The following examples show how strings can be used with variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; first_name = "Stefan" <i class="conum" data-value="1"></i><b>(1)</b>
"Stefan"
iex(2)&gt; last_name = "Wintermeyer"
"Wintermeyer"
iex(3)&gt; name = first_name &lt;&gt; " " &lt;&gt; last_name <i class="conum" data-value="2"></i><b>(2)</b>
"Stefan Wintermeyer"
iex(4)&gt; greeting = "Hello #{first_name}!" <i class="conum" data-value="3"></i><b>(3)</b>
"Hello Stefan!"
iex(5)&gt; counter = 23
23
iex(6)&gt; "Count: #{counter}" <i class="conum" data-value="4"></i><b>(4)</b>
"Count: 23"</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We assign the string "Stefan" to the variable with the name <code>first_name</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>&lt;&gt;</code> operator can be used to concatinate strings.
</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>#{}</code> is used to interpolate strings. It can be used to inject a variable
into a string.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Elixir&#8217;s string interpolation also works with integers.
By default, it can handle integers, floats, some lists (later more on lists) and
atoms.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_string_functions"><a class="anchor" href="#_string_functions"></a>String Functions</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>The <a href="https://hexdocs.pm/elixir/String.html">String module</a> contains functions for
working with strings. Here are some examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; String.downcase("SToP SHoutING!")
"stop shouting!"
iex(2)&gt; String.split("no fist is big enough to hide the sky") <i class="conum" data-value="1"></i><b>(1)</b>
["no", "fist", "is", "big", "enough", "to", "hide", "the", "sky"]
iex(3)&gt; String.split("mail@example.com", "@") <i class="conum" data-value="2"></i><b>(2)</b>
["mail", "example.com"]
iex(4)&gt; String.to_integer("555")
555</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>String.split/1</code> divides a string into substrings at each whitespace.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>String.split/2</code> is similar to <code>String.split/1</code>, but it also allows you to
define what pattern to use when splitting the string.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
remember that you can also access the documentation for the String module
in iex by running <code>h String</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_pipe_operator"><a class="anchor" href="#_the_pipe_operator"></a>The Pipe Operator (|&gt;)</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Quite often one wants to chain a couple of different functions in a row. Let&#8217;s
assume you want to reverse a string with <code>String.reverse/1</code> and capitalize it
with <code>String.capitalize/1</code> afterwards. Here&#8217;s the code to do that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; String.reverse("house") <i class="conum" data-value="1"></i><b>(1)</b>
"esuoh"
iex(2)&gt; String.capitalize("esuoh") <i class="conum" data-value="2"></i><b>(2)</b>
"Esuoh"
iex(3)&gt; String.capitalize(String.reverse("house")) <i class="conum" data-value="3"></i><b>(3)</b>
"Esuoh"</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>String.reverse/1</code> reverses the string.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>String.capitalize/1</code> capitalizes all the letters in a string.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Connect the two functions.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The problem with <code>String.capitalize(String.reverse("house"))</code> is the lack of
readability. It kind of works with just two functions, but what about one or two
more functions in that line? Here comes the pipe operator <code>|&gt;</code> to the rescue.
It is a piece of syntactic sugar. Have a look:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(4)&gt; String.reverse("house") |&gt; String.capitalize() <i class="conum" data-value="1"></i><b>(1)</b>
"Esuoh"</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The pipe operator <code>|&gt;</code> passes the result of the first function to the first
parameter of the following function.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Of course you can use multiple pipe operators:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(5)&gt; String.reverse("house") |&gt; String.capitalize() |&gt; String.slice(0, 3)
"Esu"</code></pre>
</div>
</div>
<div class="paragraph">
<p>By using the pipe operator, the code becomes more readable and more
maintainable.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lists_and_tuples"><a class="anchor" href="#_lists_and_tuples"></a>Lists and Tuples</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>We store multiple elements in lists and tuples. Lists and tuples look alike but
are quite different performance-wise.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Tuples are fast when you have to access its data but slow when you want to change its data. They are stored contiguously in memory. Accessing one element of a tuple or getting the size of it is fast and always takes the same amount of time.</p>
</li>
<li>
<p>Lists are stored as linked lists in memory. One element holds it&#8217;s own value and a link to the next element. Accessing single elements and the length of lists is a linear operation which takes more time. The longer the list, the more time it takes. But it is fast to add a new element to the end of a list.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Right now, you don&#8217;t need to lose sleep over the decision of which one to
use. Throughout the book, you&#8217;ll get a feeling which one is best suited for what
problem.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_lists"><a class="anchor" href="#_lists"></a>Lists</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Lists store multiple values, and they can contain different types. A list is
enclosed in brackets (<code>[]</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; [1, 2, 3, 4]
[1, 2, 3, 4]
iex(2)&gt; ["a", "b", "c"]
["a", "b", "c"]
iex(3)&gt; [1, "b", true, false, :blue, "house"]
[1, "b", true, false, :blue, "house"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The operators <code>++</code> and <code>--</code> can be used to concatenate and substract lists from each other:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; [1, 2] ++ [2, 4] <i class="conum" data-value="1"></i><b>(1)</b>
[1, 2, 2, 4]
iex(2)&gt; [1, 2] ++ [1] <i class="conum" data-value="2"></i><b>(2)</b>
[1, 2, 1]
iex(3)&gt; [1, "a", 2, false, true] -- ["a", 2] <i class="conum" data-value="3"></i><b>(3)</b>
[1, false, true]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Makes total sense.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>So does this.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A bit trickier. The second and third element of the first list get subtracted.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_head_and_tail_of_lists"><a class="anchor" href="#_head_and_tail_of_lists"></a>Head and Tail of Lists</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>A lot of times Elixir developers want to work with the head (the first element)
and tail (the rest) of a list. The following examples show how the functions
<code>hd/1</code> and <code>tl/1</code> can be used to return these values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; shopping_list = ["apple", "orange", "banana", "pineapple"] <i class="conum" data-value="1"></i><b>(1)</b>
["apple", "orange", "banana", "pineapple"]
iex(2)&gt; hd(shopping_list) <i class="conum" data-value="2"></i><b>(2)</b>
"apple"
iex(3)&gt; tl(shopping_list) <i class="conum" data-value="3"></i><b>(3)</b>
["orange", "banana", "pineapple"]
iex(4)&gt; shopping_list <i class="conum" data-value="4"></i><b>(4)</b>
["apple", "orange", "banana", "pineapple"]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We define a list and bind it to the variable <code>shopping_list</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>hd/1</code> fetches the first element of the list.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>tl/1</code> fetches the rest of the list.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>shopping_list</code> itself hasn&#8217;t changed.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s see what happens with empty lists or lists which just have one element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(6)&gt; hd([]) <i class="conum" data-value="1"></i><b>(1)</b>
** (ArgumentError) argument error
    :erlang.hd([])
iex(6)&gt; tl([]) <i class="conum" data-value="2"></i><b>(2)</b>
** (ArgumentError) argument error
    :erlang.tl([])
iex(6)&gt; hd(["grapefruit"]) <i class="conum" data-value="3"></i><b>(3)</b>
"grapefruit"
iex(7)&gt; tl(["grapefruit"]) <i class="conum" data-value="4"></i><b>(4)</b>
[]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You can&#8217;t get the head of an empty list.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>And there is no tail of an empty list.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>There is a "head" of a list with one element.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The "tail" of a file with one element is an empty list.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_length1"><a class="anchor" href="#_length1"></a>length/1</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>The function <code>length/1</code> tells how many elements a list contains:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex(2)&gt; length(shopping_list)
4
iex(3)&gt; length([1, 2])
2
iex(4)&gt; length([])
0</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_list_functions"><a class="anchor" href="#_list_functions"></a>List Functions</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>When working with lists, you will often use functions from the
<a href="https://hexdocs.pm/elixir/Enum.html">Enum module</a>. There is also a
<a href="https://hexdocs.pm/elixir/Enum.html">List module</a>, which contains a few useful
list functions.</p>
</div>
<div class="paragraph">
<p>Here are a few examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; numbers = [1, 5, 3, 7, 2, 3, 9, 5, 3]
[1, 5, 3, 7, 2, 3, 9, 5, 3]
iex(2)&gt; Enum.max(numbers) <i class="conum" data-value="1"></i><b>(1)</b>
9
iex(3)&gt; Enum.sort(numbers) <i class="conum" data-value="2"></i><b>(2)</b>
[1, 2, 3, 3, 3, 5, 5, 7, 9]
iex(4)&gt; words = ["nothing", "like", "the", "sun"]
["nothing", "like", "the", "sun"]
iex(5)&gt; Enum.join(words, " ")
"nothing like the sun"
iex(6)&gt; List.last(words)
"sun"</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Enum.max/1</code> returns the maximum value in a list.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>Enum.sort/1</code> returns a new list with the values sorted in ascending order.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We will see more examples from the <code>Enum</code> module when we look at higher-order
functions later in this introduction.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tuples"><a class="anchor" href="#_tuples"></a>Tuples</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Like lists, tuples can hold multiple elements of different types. The
elements are enclosed in curly braces (<code>{}</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; {1, 2, 3} <i class="conum" data-value="1"></i><b>(1)</b>
{1, 2, 3}
iex(2)&gt; {:ok, "test"} <i class="conum" data-value="2"></i><b>(2)</b>
{:ok, "test"}
iex(3)&gt; {true, :apple, 234, "house", 3.14} <i class="conum" data-value="3"></i><b>(3)</b>
{true, :apple, 234, "house", 3.14}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A tuple which contains three integers.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A tuple which contains one atom that represents the status and a string.
It is something prevalent in Elixir. You will see this a lot.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A tuple with values of different types.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We can access an element of a tuple with by passing the index to the <code>elem/2</code>
function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; result = {:ok, "Lorem ipsum"}
{:ok, "Lorem ipsum"}
iex(2)&gt; elem(result, 1) <i class="conum" data-value="1"></i><b>(1)</b>
"Lorem ipsum"
iex(3)&gt; elem(result, 0) <i class="conum" data-value="2"></i><b>(2)</b>
:ok</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The function <code>elem/2</code> gives us a fast access to each element of a tuple.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The count starts with 0 for the first element.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_tuple_functions"><a class="anchor" href="#_tuple_functions"></a>Tuple Functions</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>The <a href="https://hexdocs.pm/elixir/Tuple.html">Tuple module</a> contains functions for
working with tuples. Here are some examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Tuple.append/2</code> adds an element to a tuple.
</p>
</li>
<li>
<p><code>Tuple.delete_at/2</code> deletes an element of a tuple.
</p>
</li>
<li>
<p><code>Tuple.insert_at/3</code> adds an element at a specific position.
</p>
</li>
<li>
<p><code>Tuple.to_list/1</code> converts a tuple to a list.
</p>
</li>
<li>
<p><code>Tuple.size/1</code> returns the number of elements of the tuple.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; results = {:ok, "Lorem ipsum"}
{:ok, "Lorem ipsum"}
iex(2)&gt; b = Tuple.append(results, "Test")
{:ok, "Lorem ipsum", "Test"}
iex(3)&gt; c = Tuple.delete_at(b, 1)
{:ok, "Test"}
iex(4)&gt; d = Tuple.insert_at(b, 1, "ipsum")
{:ok, "ipsum", "Lorem ipsum", "Test"}
iex(5)&gt; new_list = Tuple.to_list(d)
[:ok, "ipsum", "Lorem ipsum", "Test"]
iex(6)&gt; tuple_size(d)
4</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_higher_order_functions"><a class="anchor" href="#_higher_order_functions"></a>Higher-Order Functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Elixir, functions can be used like any other variable. For example, they can
be passed to other functions as parameters.</p>
</div>
<div class="paragraph">
<p>A function that takes another function as one of its parameters is called a
higher-order function, and these are very commonly used in Elixir.</p>
</div>
<div class="paragraph">
<p>When passing a function to a higher-order function, we need to use an anonymous
function, and that is what we will look at next.</p>
</div>
<div class="sect2">
<h3 id="_anonymous_functions"><a class="anchor" href="#_anonymous_functions"></a>Anonymous Functions</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Anonymous functions are functions that are defined without any name.</p>
</div>
<div class="paragraph">
<p>You define anonymous functions using the <code>fn</code> keyword:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; greeting = fn(name) -&gt; "Hello #{name}!" end <i class="conum" data-value="1"></i><b>(1)</b>
#Function&lt;7.126501267/1 in :erl_eval.expr/5&gt;
iex(2)&gt; greeting.("Bob") <i class="conum" data-value="2"></i><b>(2)</b>
"Hello Bob!"
iex(3)&gt; greeting.("Alice")
"Hello Alice!"
iex(4)&gt; square_area = fn a -&gt; a * a end <i class="conum" data-value="3"></i><b>(3)</b>
#Function&lt;7.126501267/1 in :erl_eval.expr/5&gt;
iex(5)&gt; square_area.(10)
100
iex(6)&gt; area = fn width, length -&gt; width * length end <i class="conum" data-value="4"></i><b>(4)</b>
#Function&lt;13.126501267/2 in :erl_eval.expr/5&gt;
iex(7)&gt; area.(2,8)
16</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We create an anonymous function and bind it to the variable <code>greeting</code>.
<div class="ulist">
<ul>
<li>
<p><code>fn</code> tells Elixir that you want to define a function.</p>
</li>
<li>
<p><code>name</code> is a parameter we can use to inject values.</p>
</li>
<li>
<p><code>&#8594;</code> is the operator to indicate the following expression is the body of the function.</p>
</li>
<li>
<p><code>end</code> indicates the end of the function.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We need to use the <code>.</code> (dot) operator to run anonymous functions.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>You don&#8217;t have to surround the function arguments with parentheses. They
are optional.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Like regular functions, anonymous functions can be called with multiple
arguments. The arguments are separated by commas.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Most of the time anonymous functions are simple one liners. But they don&#8217;t have to be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; circular_area = fn radius -&gt;
...(1)&gt;   pi = 3.14159265359
...(1)&gt;   pi * radius * radius
...(1)&gt; end
#Function&lt;7.126501267/1 in :erl_eval.expr/5&gt;
iex(2)&gt; circular_area.(3)
28.274333882310003</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s now look at using anonymous functions with higher-order functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; numbers = [1,2,3,4,5,6,7,8,9]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
iex(2)&gt; Enum.filter(numbers, fn num -&gt; rem(num, 2) == 0 end) <i class="conum" data-value="1"></i><b>(1)</b>
[2, 4, 6, 8]
iex(6)&gt; Enum.map(numbers, fn x -&gt; x * x end) <i class="conum" data-value="2"></i><b>(2)</b>
[1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Enum.filter/2</code> filters a list and returns those elements for which the
function returns true. The <code>rem/2</code> function calculates the remainder after
integer division.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>Enum.map/2</code> calls the given function for every item in the list and returns a
new list.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_the_operator"><a class="anchor" href="#_the_operator"></a>The &amp; operator</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Another way of creating anonymous functions is to use the <code>&amp;</code> operator, which
is called the <strong>capture operator</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; second = &amp;Enum.at(&amp;1, 1) <i class="conum" data-value="1"></i><b>(1)</b>
#Function&lt;44.97283095/1 in :erl_eval.expr/5&gt;
iex(2)&gt; second.([1,2,3,4]) <i class="conum" data-value="2"></i><b>(2)</b>
2
iex(3)&gt; is_negative? = &amp;(&amp;1 &lt; 0)
#Function&lt;44.97283095/1 in :erl_eval.expr/5&gt;
iex(4)&gt; is_negative?.(-1)
true</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>&amp;1</code> refers to the first parameter.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Again, we need to use the <code>.</code> (dot) operator to run anonymous functions.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And here are examples of using the capture operator with higher-order functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; maybe_numbers = [1, nil, 4, nil, 5]
[1, nil, 4, nil, 5]
iex(2)&gt; Enum.filter(maybe_numbers, &amp;is_integer(&amp;1)) <i class="conum" data-value="1"></i><b>(1)</b>
[1, 4, 5]
iex(3)&gt; Enum.filter(maybe_numbers, &amp;is_integer/1) <i class="conum" data-value="2"></i><b>(2)</b>
[1, 4, 5]
iex(4)&gt; Enum.sort([1, 2, 3], &amp;(&amp;1 &gt;= &amp;2)) <i class="conum" data-value="3"></i><b>(3)</b>
[3, 2, 1]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>&amp;1</code> refers to the first parameter.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The same as the previous function, but with a different syntax. The <code>/1</code>
after <code>is_integer</code> means that the function takes one parameter.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>You can use multiple parameters too (e.g. <code>&amp;1</code>, <code>&amp;2</code>).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sometimes it is more convenient to use the <code>&amp;</code> operator, but there are times
when it makes the expression more difficult to read.</p>
</div>
</div>
<div class="sect2">
<h3 id="_variable_scopes"><a class="anchor" href="#_variable_scopes"></a>Variable Scopes</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>In every programming language variables have some sort of scope. Let&#8217;s have a
look into some code to figure out how variables in Elixir are scoped:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; area = 5 <i class="conum" data-value="1"></i><b>(1)</b>
5
iex(2)&gt; IO.puts(area)
5
:ok
iex(3)&gt; square_area = fn a -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
...(3)&gt;   area = a * a <i class="conum" data-value="3"></i><b>(3)</b>
...(3)&gt;   area
...(3)&gt; end
#Function&lt;7.126501267/1 in :erl_eval.expr/5&gt;
iex(4)&gt; square_area.(10) <i class="conum" data-value="4"></i><b>(4)</b>
100
iex(5)&gt; IO.puts(area) <i class="conum" data-value="5"></i><b>(5)</b>
5
:ok</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We bind the value of 5 to the variable <code>area</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We define an anonymous function.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Within this function we bind the result of our calculation to another variable <code>area</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Run the function with an argument of 10. That would mean that the <code>area</code> in the function gets set to the value 100.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The original <code>area</code> hasn&#8217;t changed a bit. Because it is in a different scope.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>area</code> within the function is in an inner scope. The original <code>area</code> is in an outer scope.</p>
</div>
<div class="paragraph">
<p>But it gets a bit more complex:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; pi = 3.14159265359 <i class="conum" data-value="1"></i><b>(1)</b>
3.14159265359
iex(2)&gt; circular_area = fn radius -&gt; pi * radius * radius end <i class="conum" data-value="2"></i><b>(2)</b>
#Function&lt;7.126501267/1 in :erl_eval.expr/5&gt;
iex(3)&gt; circular_area.(10)
314.15926535899996</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We bind the value 3.14159265359 to the variable with the name <code>pi</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We create an anonymous function which uses the variable <code>pi</code> to make the calculation.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>So we can read the outer scope variable from within the function. So lets check
if we can change it too:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; pi = 3.14159265359 <i class="conum" data-value="1"></i><b>(1)</b>
3.14159265359
iex(2)&gt; circular_area = fn radius -&gt;
...(2)&gt;   pi = 3.14 <i class="conum" data-value="2"></i><b>(2)</b>
...(2)&gt;   pi * radius * radius
...(2)&gt; end
#Function&lt;7.126501267/1 in :erl_eval.expr/5&gt;
iex(3)&gt; circular_area.(10) <i class="conum" data-value="3"></i><b>(3)</b>
314.0
iex(4)&gt; IO.puts(pi) <i class="conum" data-value="4"></i><b>(4)</b>
3.14159265359
:ok</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We bind the value 3.14159265359 to the variable with the name <code>pi</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We bind the inner scoped variable <code>pi</code> with the value 3.14.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The 3.14 and not the 3.14159265359 gets used.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The outer scoped <code>pi</code> is not changed.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can not change the value of an outer scoped variable, but you can read
it. And you can create a new inner scope variable with the same name without
interacting with the outer scoped one.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_keyword_lists_maps_and_structs"><a class="anchor" href="#_keyword_lists_maps_and_structs"></a>Keyword Lists, Maps and Structs</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>List and Tuples don&#8217;t provide the functionality to access values with a key. We
can achieve that functionality with keyword lists, maps and structs.</p>
</div>
<div class="sect2">
<h3 id="_keyword_lists"><a class="anchor" href="#_keyword_lists"></a>Keyword Lists</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Keyword lists are key-value data structures, in which keys are atoms and keys
can appear more than once.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; user = [{:name, "joe"}, {:age, 23}] <i class="conum" data-value="1"></i><b>(1)</b>
[name: "joe", age: 23]
iex(2)&gt; user = [name: "joe", age: 23] <i class="conum" data-value="2"></i><b>(2)</b>
[name: "joe", age: 23]
iex(3)&gt; user[:name] <i class="conum" data-value="3"></i><b>(3)</b>
"joe"
iex(4)&gt; new_user = [name: "fred"] ++ user
[name: "fred", name: "joe", age: 23]
iex(5)&gt; new_user[:name] <i class="conum" data-value="4"></i><b>(4)</b>
"fred"</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Keyword lists are lists of 2-item tuples, with the first item of each tuple
being an atom.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This <code>[<em>key</em>: <em>value</em>]</code> syntax is more commonly used (this expression is
the same as the list of tuples above).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The keyword list name followed by the key name in brackets returns a value
for the given key.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>If there are duplicate keys in a keyword list, the first one is fetched on
lookup.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In your Phoenix application, you will see a keyword list used as the last
argument in the <code>render/3</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">render(conn, "show.html", message: "Hello", username: "Mary") <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>[message: "Hello", username: "Mary"]</code> is a keyword list. As you can see
from this example, the brackets are optional.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_keyword_list_functions"><a class="anchor" href="#_keyword_list_functions"></a>Keyword List Functions</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>The <a href="https://hexdocs.pm/elixir/Keyword.html">Keyword module</a> offers functions for
working with keyword lists.</p>
</div>
<div class="paragraph">
<p>Here are a few examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; Keyword.get([age: 34, height: 155], :height)
155
iex(2)&gt; Keyword.delete([length: 78, width: 104], :length)
[width: 104] <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>After deleting the <code>:length</code>, the keyword list just contains the <code>:width</code>
key-value pair.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_maps"><a class="anchor" href="#_maps"></a>Maps</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Maps provide a way to store and retrieve key-value pairs. The <code>%{}</code> syntax
creates a Map.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; product_prices = %{"Apple" =&gt; 0.5, "Orange" =&gt; 0.7} <i class="conum" data-value="1"></i><b>(1)</b>
%{"Apple" =&gt; 0.5, "Orange" =&gt; 0.7}
iex(2)&gt; product_prices["Orange"] <i class="conum" data-value="2"></i><b>(2)</b>
0.7
iex(3)&gt; product_prices["Banana"] <i class="conum" data-value="3"></i><b>(3)</b>
nil
iex(4)&gt; product_prices = %{"Apple" =&gt; 0.5, "Orange" =&gt; 0.7, "Apple" =&gt; 1}
warning: key "Apple" will be overridden in map
  iex:4

%{"Apple" =&gt; 1, "Orange" =&gt; 0.7} <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We create a new map and bind it to the variable <code>product_prices</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The map name followed by the key name in brackets returns a value for the given key.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This returns nil if a given key doesn&#8217;t exist.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Unlike keyword lists, maps cannot contain duplicate keys.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>But keys don&#8217;t have to be a specific type. Everything can be a key and a value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; %{"one" =&gt; 1, "two" =&gt; "abc", 3 =&gt; 7, true =&gt; "asdf"} <i class="conum" data-value="1"></i><b>(1)</b>
%{3 =&gt; 7, true =&gt; "asdf", "one" =&gt; 1, "two" =&gt; "abc"}
iex(2)&gt; %{"one" =&gt; 1, true =&gt; "asdf", true =&gt; "z"} <i class="conum" data-value="2"></i><b>(2)</b>
warning: key true will be overridden in map
  iex:2

%{true =&gt; "z", "one" =&gt; 1}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A mixed bag of different types. Feel free to go wild.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A key has to be unique within a map. The last one overwrites the previous
values. In this case, the key <code>true</code> will have a value of "z".</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_atom_keys"><a class="anchor" href="#_atom_keys"></a>Atom keys</h4>
<div class="paragraph">
<p>Using atoms as keys in maps gives you access to some nifty features:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; product_prices = %{apple: 0.5, orange: 0.7} <i class="conum" data-value="1"></i><b>(1)</b>
%{apple: 0.5, orange: 0.7}
iex(2)&gt; product_prices.apple <i class="conum" data-value="2"></i><b>(2)</b>
0.5
iex(3)&gt; product_prices.banana <i class="conum" data-value="3"></i><b>(3)</b>
** (KeyError) key :banana not found in: %{apple: 0.5, orange: 0.7}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>With atoms as keys you can use this syntax which is a bit easier to read and less work to type.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>When using atom keys, you can use the dot operator (<code>.</code>) to return the value of a given key.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If you use the dot operator and the key does not exist, an error is raised.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_map_functions"><a class="anchor" href="#_map_functions"></a>Map Functions</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>The <a href="https://hexdocs.pm/elixir/Map.html">Map module</a> offers many useful functions
for working with maps.</p>
</div>
<div class="paragraph">
<p>Here are just a few examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; product_prices = %{apple: 0.5, orange: 0.7, coconut: 1}
%{apple: 0.5, coconut: 1, orange: 0.7}
iex(2)&gt; Map.to_list(product_prices) <i class="conum" data-value="1"></i><b>(1)</b>
[apple: 0.5, coconut: 1, orange: 0.7]
iex(3)&gt; Map.values(product_prices) <i class="conum" data-value="2"></i><b>(2)</b>
[0.5, 1, 0.7]
iex(4)&gt; Map.split(product_prices, [:orange, :apple]) <i class="conum" data-value="3"></i><b>(3)</b>
{%{apple: 0.5, orange: 0.7}, %{coconut: 1}}
iex(5)&gt; a = Map.delete(product_prices, :orange) <i class="conum" data-value="4"></i><b>(4)</b>
%{apple: 0.5, coconut: 1}
iex(6)&gt; b = Map.drop(product_prices, [:apple, :orange]) <i class="conum" data-value="5"></i><b>(5)</b>
%{coconut: 1}
iex(7)&gt; additional_prices = %{banana: 0.4, pineapple: 1.2}
%{banana: 0.4, pineapple: 1.2}
iex(8)&gt; Map.merge(product_prices, additional_prices) <i class="conum" data-value="6"></i><b>(6)</b>
%{apple: 0.5, banana: 0.4, coconut: 1, orange: 0.7, pineapple: 1.2}
iex(9)&gt; c = Map.put(product_prices, :potato, 0.2) <i class="conum" data-value="7"></i><b>(7)</b>
%{apple: 0.5, coconut: 1, orange: 0.7, potato: 0.2}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Map.to_list/1</code> converts a map into a keyword list.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>Map.values/1</code> returns the values of a map.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>Map.split/2</code> splits a given map into two new maps. The first one contains
all the key-value pairs which are requested by a list (e.g. <code>[:orange, :apple]</code>)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>Map.delete/2</code> deletes a specific key-value pair from a map.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>Map.drop/2</code> deletes a list of key-value pairs from a map.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><code>Map.merge/2</code> merges two maps.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td><code>Map.put/2</code> adds a key-value pair to a map.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_structs"><a class="anchor" href="#_structs"></a>Structs</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>A struct is a map that provides compile-time checks and default values. To
define a struct you have to use the <code>defstruct</code> construct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Product do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;   defstruct name: nil, price: 0 <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt; end
{:module, Product, ...
iex(2)&gt; %Product{}
%Product{name: nil, price: 0}
iex(3)&gt; apple = %Product{name: "Apple", price: 0.5} <i class="conum" data-value="3"></i><b>(3)</b>
%Product{name: "Apple", price: 0.5}
iex(4)&gt; apple
%Product{name: "Apple", price: 0.5}
iex(5)&gt; apple.price
0.5
iex(6)&gt; orange = %Product{name: "Orange"} <i class="conum" data-value="4"></i><b>(4)</b>
%Product{name: "Orange", price: 0}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We define a new struct with the name <code>Product</code> and the keys <code>name</code> and <code>price</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We define default values.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We define a new Product struct and set all values.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We define a new Product struct and set only the name. The price is set to
the default value.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A struct guarantees that only the defined fields are allowed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(7)&gt; apple.description <i class="conum" data-value="1"></i><b>(1)</b>
** (KeyError) key :description not found in: %Product{name: "Apple", price: 0.5}

iex(7)&gt; banana = %Product{name: "Banana", weight: 0.1} <i class="conum" data-value="2"></i><b>(2)</b>
** (KeyError) key :weight not found
    expanding struct: Product.__struct__/1
    iex:7: (file)
iex(7)&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Since we didn&#8217;t define a <code>description</code> field in the Struct, we cannot access it.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Same with a new struct. There is no <code>weight</code> field defined. Therefore we can not set it.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Because structs are built on top of maps, they can be used with the same
functions.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pattern_matching"><a class="anchor" href="#_pattern_matching"></a>Pattern Matching</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Pattern matching is essential in Elixir, and we have already used it, without
knowing it, for binding values to variables.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; a = 10 <i class="conum" data-value="1"></i><b>(1)</b>
10
iex(2)&gt; a
10
iex(3)&gt; {b, c} = {10, 15} <i class="conum" data-value="2"></i><b>(2)</b>
{10, 15}
iex(4)&gt; b
10
iex(5)&gt; c
15
iex(6)&gt; {d, e} = 100
** (MatchError) no match of right hand side value: 100 <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is actually a pattern match. The left side of <code>=</code> will be matched to the right site if possible.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here we pattern match <code>{b, c}</code> on the left side with a tuple on the right side.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Boom! Because we can not match the <code>{d, e}</code> tuple with an integer we get a <code>MatchError</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since we don&#8217;t have much time, I&#8217;ll fast forward to match a head and tail of a
list. Because there is a special syntax for that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; shopping_list = ["apple", "orange", "banana", "pineapple"] <i class="conum" data-value="1"></i><b>(1)</b>
["apple", "orange", "banana", "pineapple"]
iex(2)&gt; [head | tail] = shopping_list <i class="conum" data-value="2"></i><b>(2)</b>
["apple", "orange", "banana", "pineapple"]
iex(3)&gt; head
"apple"
iex(4)&gt; tail
["orange", "banana", "pineapple"]
iex(5)&gt; [a | b] = tail <i class="conum" data-value="3"></i><b>(3)</b>
["orange", "banana", "pineapple"]
iex(6)&gt; a
"orange"
iex(7)&gt; b
["banana", "pineapple"]
iex(8)&gt; [first_product, second_product | tail] = shopping_list <i class="conum" data-value="4"></i><b>(4)</b>
["apple", "orange", "banana", "pineapple"]
iex(9)&gt; first_product
"apple"
iex(10)&gt; second_product
"orange"
iex(11)&gt; tail
["banana", "pineapple"]
iex(12)&gt; [first_product | [second_product | tail]] = shopping_list <i class="conum" data-value="5"></i><b>(5)</b>
["apple", "orange", "banana", "pineapple"]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We match a list to the variable <code>shopping_list</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>[head | tail]</code> is the special syntax to match a head and tail of a given list.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Again we match the head <code>a</code> and the tail <code>b</code> with <code>tail</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>A bit more complex. We match agains the first and second product followed by a tail.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Same result. Different syntax and logic. Pick the one you prefer.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Of course, if we know that a list has a specific number of elements we can match
it directly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex(2)&gt; [a, b, c, d] = shopping_list
["apple", "orange", "banana", "pineapple"]
iex(3)&gt; a
"apple"
iex(4)&gt; b
"orange"
iex(5)&gt; [e, f, g] = shopping_list <i class="conum" data-value="1"></i><b>(1)</b>
** (MatchError) no match of right hand side value: ["apple", "orange", "banana", "pineapple"]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Just checking. You get an <code>MatchError</code> if Elixir can&#8217;t match both sides.</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_matching_maps"><a class="anchor" href="#_matching_maps"></a>Matching Maps</h3>
<div class="paragraph">
<p>Matching a Map works a little bit different to matching a Tuple or List.
You can match just against the values you are interested in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; product_prices = %{apple: 0.5, orange: 0.7, pineapple: 1}
%{apple: 0.5, orange: 0.7, pineapple: 1}
iex(2)&gt; %{orange: price} = product_prices <i class="conum" data-value="1"></i><b>(1)</b>
%{apple: 0.5, orange: 0.7, pineapple: 1}
iex(3)&gt; price
0.7
iex(4)&gt; %{orange: price1, apple: price2} = product_prices <i class="conum" data-value="2"></i><b>(2)</b>
%{apple: 0.5, orange: 0.7, pineapple: 1}
iex(5)&gt; price1
0.7
iex(6)&gt; price2
0.5</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We can just match one value.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Or we can match multiple values. But we don&#8217;t have to match the whole Map.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_matching_string_parts"><a class="anchor" href="#_matching_string_parts"></a>Matching String parts</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Easiest explained with a code example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; user = "Stefan Wintermeyer"
"Stefan Wintermeyer"
iex(2)&gt; "Stefan " &lt;&gt; last_name = user
"Stefan Wintermeyer"
iex(3)&gt; last_name
"Wintermeyer"</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The left side of a <code>&lt;&gt;</code> operator in a match should always be a string.
Otherwise, Elixir can&#8217;t verify it&#8217;s size.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_wildcard_matching"><a class="anchor" href="#_wildcard_matching"></a>Wildcard Matching</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Sometimes you need pattern matching to get a value, but you don&#8217;t need all of
the values in the pattern. For those cases, you can use <code>_</code> (alone or as a
prefix to a variable name). It indicates to Elixir that you don&#8217;t need that
variable to be bound to anything.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; shopping_list = ["apple", "orange", "banana", "pineapple"]
["apple", "orange", "banana", "pineapple"]
iex(2)&gt; [first_product | _tail] = shopping_list <i class="conum" data-value="1"></i><b>(1)</b>
["apple", "orange", "banana", "pineapple"]
iex(3)&gt; first_product
"apple"
iex(4)&gt; [head | _] = shopping_list <i class="conum" data-value="2"></i><b>(2)</b>
["apple", "orange", "banana", "pineapple"]
iex(5)&gt; head
"apple"</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We pattern match the head of <code>shopping_list</code> to <code>first_product</code>. But we don&#8217;t need the tail, and we indicate that by prefixing it with a <code>_</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We can use just a <code>_</code> too. Using <code>_tail</code> just improves the code readability
a bit.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_pattern_matching_with_functions"><a class="anchor" href="#_pattern_matching_with_functions"></a>Pattern Matching with Functions</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Pattern matching is used everywhere in Elixir. You can even use it with Functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Area do
...(1)&gt;   def circle(:exact, radius) do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;     3.14159265359 * radius * radius
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def circle(:normal, radius) do <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;     3.14 * radius * radius
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def circle(radius) do <i class="conum" data-value="3"></i><b>(3)</b>
...(1)&gt;     circle(:normal, radius)
...(1)&gt;   end
...(1)&gt; end
{:module, Area, ...
iex(2)&gt; Area.circle(:exact, 4)
50.26548245744
iex(3)&gt; Area.circle(:normal, 4)
50.24
iex(4)&gt; Area.circle(4)
50.24</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We define a <code>circle/2</code> function which matches if the first argument is the atom <code>:exact</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We define a <code>circle/2</code> function which matches if the first argument is the atom <code>:normal</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We define a <code>circle/1</code> function which calls the <code>cirle/2</code> function with the <code>:normal</code> argument.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_functions_with_guards"><a class="anchor" href="#_functions_with_guards"></a>Functions with Guards</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Guards add some additional spices to pattern matching with functions. You can find
all the details at <a href="https://hexdocs.pm/elixir/guards.html" class="bare">https://hexdocs.pm/elixir/guards.html</a></p>
</div>
<div class="paragraph">
<p>Here are just some examples to show you the concept. Guards start with <code>when</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Law do
...(1)&gt;   def can_vote?(age) when is_integer(age) and age &gt; 17 do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;     true
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def can_vote?(age) when is_integer(age) do <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;     false
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def can_vote?(_age) do <i class="conum" data-value="3"></i><b>(3)</b>
...(1)&gt;     raise ArgumentError, "age should be an integer"
...(1)&gt;   end
...(1)&gt; end
{:module, Law, ...
iex(2)&gt; Law.can_vote?(15)
false
iex(3)&gt; Law.can_vote?(20)
true
iex(4)&gt; Law.can_vote?("test") <i class="conum" data-value="4"></i><b>(4)</b>
** (ArgumentError) age should be an integer
    iex:4: Law.can_vote?/1</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This guard checks if the <code>age</code> argument is an integer and the value of it is bigger than 17.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This guard just checks if the <code>age</code> argument is an integer.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This clause catches any value that is not called with an integer.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Since <code>"test"</code> is a string and not an integer, the ArgumentError that we
wrote is raised.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_case"><a class="anchor" href="#_case"></a>Case</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p><code>case</code> is a control structure which matches a given value to a couple of
matching cases until one matches.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume we want to create a function that converts morse coded
numbers to integers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Morse do
...(1)&gt;   def morse_to_number(input) do
...(1)&gt;     case input do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;       "-----" -&gt; 0 <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;       ".----" -&gt; 1
...(1)&gt;       "..---" -&gt; 2
...(1)&gt;       "...--" -&gt; 3
...(1)&gt;       "....-" -&gt; 4
...(1)&gt;       "....." -&gt; 5
...(1)&gt;       "-...." -&gt; 6
...(1)&gt;       "--..." -&gt; 7
...(1)&gt;       "---.." -&gt; 8
...(1)&gt;       "----." -&gt; 9
...(1)&gt;       _ -&gt; :error <i class="conum" data-value="3"></i><b>(3)</b>
...(1)&gt;     end
...(1)&gt;   end
...(1)&gt; end
{:module, Morse, ...
iex(2)&gt; Morse.morse_to_number("-....") <i class="conum" data-value="4"></i><b>(4)</b>
6</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>After <code>case</code> comes the value we want to check.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>"-----"</code> is the expression we want to match to return a 0.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>_</code> is the catch-all in case nothing matched yet. In this case, return an <code>:error</code> atom.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>It works. :-)</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Of course, we could solve this problem just with functions too. It&#8217;s up to you what makes the most sense in a given situation.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_if_and_unless"><a class="anchor" href="#_if_and_unless"></a>if and unless</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p><code>if</code> is common to many programming languages. <code>unless</code> is equivalent to <code>if
not</code>. The following examples will show how to use them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; if 1 == 1 do
...(1)&gt;   "Bingo!"
...(1)&gt; else
...(1)&gt;   "Negative"
...(1)&gt; end
"Bingo!"
iex(2)&gt; unless true do
...(2)&gt;   "Never"
...(2)&gt; end
nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes you see a one-line short form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(3)&gt; if 1 == 1, do: "Bingo!"
"Bingo!"</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Most Elixir developers prefer <code>case</code> over <code>if</code> or <code>unless</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_immutability"><a class="anchor" href="#_immutability"></a>Immutability</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Probably you have already heard about immutability in Elixir. What&#8217;s that about?</p>
</div>
<div class="paragraph">
<p>A variable points to a specific part of the memory where the data is stored. In
many programming languages that data can be changed to update a variable. In
Elixir, you can&#8217;t change it. So that doesn&#8217;t mean that you can&#8217;t rebind a
variable to a different value but that this new value gets a new piece of memory
and doesn&#8217;t overwrite the old memory. Once a function returns a result and
therefore, has finished its work, everything gets garbage collected (wiped
blank).</p>
</div>
<div class="paragraph">
<p>Why is that important at all? With immutable variables, we can be sure that
other processes can not change their values while running parallel tasks.  That
has a massive effect. In the end, it means that your Phoenix application can run
on multiple CPUs on the same server in parallel. It even means that your Phoenix
application can share multiple CPUs on several nodes of a server cluster in your
data center; this makes Elixir extremely scalable and save.</p>
</div>
<div class="paragraph">
<p>But doesn&#8217;t that make your application slower? Funny thing: No. This way is
faster. It is not efficient to change data in memory.</p>
</div>
<div class="paragraph">
<p>But don&#8217;t worry. It is not as complicated as it sounds. Everytime you use a
variable it uses the value of that moment in time. It will not be
effected/changed afterwords:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; product = "Orange"
"Orange"
iex(2)&gt; test1 = fn -&gt; IO.puts(product) end <i class="conum" data-value="1"></i><b>(1)</b>
#Function&lt;21.126501267/0 in :erl_eval.expr/5&gt;
iex(3)&gt; product = "Apple"
"Apple"
iex(4)&gt; test2 = fn -&gt; IO.puts(product) end
#Function&lt;21.126501267/0 in :erl_eval.expr/5&gt;
iex(5)&gt; product = "Pineapple"
"Pineapple"
iex(6)&gt; test3 = fn -&gt; IO.puts(product) end
#Function&lt;21.126501267/0 in :erl_eval.expr/5&gt;
iex(7)&gt; product = "Banana"
"Banana"
iex(8)&gt; test1.() <i class="conum" data-value="2"></i><b>(2)</b>
Orange
:ok
iex(9)&gt; test2.()
Apple
:ok
iex(10)&gt; test3.()
Pineapple
:ok
iex(11)&gt; IO.puts(product)
Banana
:ok</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Those anonymous functions may run on totally different CPUs. The life in their own little universe.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The value of <code>product</code> has changed multiple times. But for <code>test1.()</code> it is the value from that point in time when we created the function.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sigils"><a class="anchor" href="#_sigils"></a>Sigils</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Until now encapsulated Strings in double quotes and we haven&#8217;t talked about char
lists at all (IMO not needed for a beginners introduction). But there is one more mechanism to represent texts. They are called <code>Sigils</code> and start with a <code>~</code> (tilde) character which is followed by one letter which indicates what kind of sigil it is. After that, you can use a couple of different delimiters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">~r/example text/
~r|example text|
~r"example text"
~r'example text'
~r(example text)
~r[example text]
~r{example text}
~r&lt;example text&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Elixir provides different delimiters for sigils so that you can write
literals without escaped delimiters.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_regular_expressions"><a class="anchor" href="#_regular_expressions"></a>Regular expressions</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p><code>~r</code> marks a <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expression</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; regex = ~r/bcd/
~r/bcd/
iex(2)&gt; "abcde" =~ regex
true
iex(3)&gt; "efghi" =~ regex
false
iex(4)&gt; regex = ~r/stef/i <i class="conum" data-value="1"></i><b>(1)</b>
~r/stef/i
iex(5)&gt; "Stefan" =~ regex
true</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Modifiers are supported too. For a complete list have a look at <a href="https://hexdocs.pm/elixir/Regex.html" class="bare">https://hexdocs.pm/elixir/Regex.html</a></td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_string"><a class="anchor" href="#_string"></a>String</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>You can use the <code>~s</code> sigil to generate a string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; example = ~s(WOW! "double" and 'single' quotes without escaping)
"WOW! \"double\" and 'single' quotes without escaping"
iex(2)&gt; IO.puts(example)
WOW! "double" and 'single' quotes without escaping
:ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sigils support heredocs too. You can use triple, double, or single quotes as
separators:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; example_text = ~s"""
...(1)&gt; This is an example text.
...(1)&gt; Multiple lines are not a problem.
...(1)&gt; """
"This is an example text.\nMultiple lines are not a problem.\n"
iex(2)&gt; IO.puts(example_text)
This is an example text.
Multiple lines are not a problem.

:ok</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_word_lists"><a class="anchor" href="#_word_lists"></a>Word lists</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>The <code>~w</code> sigil is a useful way to generate lists of words:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; shopping_cart = ~w(apple orange banana)
["apple", "orange", "banana"]
iex(2)&gt; shopping_cart_atoms = ~w(apple orange banana)a <i class="conum" data-value="1"></i><b>(1)</b>
[:apple, :orange, :banana]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>a</code> modifier tells Elixir to generate a list of atoms and not strings.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_date_and_time"><a class="anchor" href="#_date_and_time"></a>Date and Time</h3>
<div class="paragraph">
<p>Elixir provides a couple of good to go time-related Struct[structs] which all have their sigil.</p>
</div>
<div class="sect3">
<h4 id="_date"><a class="anchor" href="#_date"></a>Date</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Elixir provides a <code>%Date{}</code> struct that contains the following fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>year</code></p>
</li>
<li>
<p><code>month</code></p>
</li>
<li>
<p><code>day</code></p>
</li>
<li>
<p><code>calendar</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With the <code>~D</code> sigil you can create new <code>%Date{}</code> struct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; birthday = ~D[1973-03-23]
~D[1973-03-23]
iex(2)&gt; birthday.day
23
iex(3)&gt; birthday.month
3
iex(4)&gt; birthday.year
1973</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_time"><a class="anchor" href="#_time"></a>Time</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Elixir provides a <code>%Time{}</code> struct that contains the following fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hour</code></p>
</li>
<li>
<p><code>minute</code></p>
</li>
<li>
<p><code>second</code></p>
</li>
<li>
<p><code>microsecond</code></p>
</li>
<li>
<p><code>calendar</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With the <code>~T</code> sigil you can create new <code>%Time{}</code> struct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; now = ~T[09:29:00.0]
~T[09:29:00.0]
iex(2)&gt; now.hour
9</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_naivedatetime"><a class="anchor" href="#_naivedatetime"></a>NaiveDateTime</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>The <code>%NaiveDateTime{}</code> struct mixes <code>%Date{}</code> with <code>%Time{}</code>.</p>
</div>
<div class="paragraph">
<p>With the <code>~N</code> sigil you can create new <code>%NaiveDateTime{}</code> struct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; timestamp = ~N[2020-05-08 09:48:00]
~N[2020-05-08 09:48:00]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_datetime"><a class="anchor" href="#_datetime"></a>DateTime</h4>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>The <code>%DateTime{}</code> struct adds a timezone to a <code>%NaiveDateTime{}</code>.</p>
</div>
<div class="paragraph">
<p>With the <code>~U</code> sigil you can create new <code>%NaiveDateTime{}</code> struct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(4)&gt; timestamp = ~U[2029-05-08 09:59:03Z]
~U[2029-05-08 09:59:03Z]</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Find more information about timezones and DateTime at <a href="https://hexdocs.pm/elixir/DateTime.html" class="bare">https://hexdocs.pm/elixir/DateTime.html</a>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_recursion"><a class="anchor" href="#_recursion"></a>Recursion</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Recursions are often used when you would use a loop in an object-oriented
language.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s write a recursive function which provides a countdown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Example do
...(1)&gt;   def countdown(1) do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;     IO.puts "1" <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def countdown(n) when is_integer(n) and n &gt; 1 do <i class="conum" data-value="3"></i><b>(3)</b>
...(1)&gt;     IO.puts Integer.to_string(n) <i class="conum" data-value="4"></i><b>(4)</b>
...(1)&gt;     countdown(n - 1) <i class="conum" data-value="5"></i><b>(5)</b>
...(1)&gt;   end
...(1)&gt; end
{:module, Example, ...
iex(2)&gt; Example.countdown(4) <i class="conum" data-value="6"></i><b>(6)</b>
4
3
2
1
:ok</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If <code>countdown/1</code> is called with the argument <code>1</code> this is the best match.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We call <code>IO.puts("1")</code> to print 1 to STDOUT.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If <code>countdown/1</code> is called with an integer bigger than 1 as an argument this function matches.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We have to use <code>Integer.to_string(n)</code> to print the integer to STDOUT.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>We recursively decrese <code>n</code> by 1 and call <code>countdown/1</code> with that new number.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>It works!</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here&#8217;s a different example where we calculate the sum of a list of integers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Example do
...(1)&gt;   def sum([]) do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;     0
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def sum([head | tail]) do <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;     head + sum(tail) <i class="conum" data-value="3"></i><b>(3)</b>
...(1)&gt;   end
...(1)&gt; end
{:module, Example, ...
iex(2)&gt; Example.sum([10, 8, 12, 150]) <i class="conum" data-value="4"></i><b>(4)</b>
180
iex(3)&gt; [head | tail] = [150] <i class="conum" data-value="5"></i><b>(5)</b>
[150]
iex(4)&gt; tail
[]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The sum of an empty list is 0.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We pattern match a list and split it into a <code>head</code> and a <code>tail</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We add the current <code>head</code> to the sum of the <code>tail</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>It works!</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This is just to show how Elixir handles the case of a list with one element.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can use the same concept to transform every element of a list. Let&#8217;s assume
we want to double the value of every element of a list:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">iex(1)&gt; defmodule Example do
...(1)&gt;   def double([]) do <i class="conum" data-value="1"></i><b>(1)</b>
...(1)&gt;     []
...(1)&gt;   end
...(1)&gt;
...(1)&gt;   def double([head | tail]) do
...(1)&gt;     [head * 2 | double(tail)] <i class="conum" data-value="2"></i><b>(2)</b>
...(1)&gt;   end
...(1)&gt; end
{:module, Example, ...
iex(2)&gt; Ex
Example      Exception
iex(2)&gt; Example.double([10, 5, 999])
[20, 10, 1998]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We again start with the most simple match. An empty list. That will result in an empty list.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>[head | tail]</code> syntax works both ways. We can use it to build a list too.</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_how_to_tackle_a_recursion"><a class="anchor" href="#_how_to_tackle_a_recursion"></a>How to tackle a recursion</h3>
<div class="paragraph">
<p>Unless you are doing this every day, you will get to problems where you know
that recursion is a good solution, but you just can&#8217;t think of a good recursion
for it.</p>
</div>
<div class="paragraph">
<p>Let me share a pro tip for these situations: <a href="https://www.google.com" class="bare">https://www.google.com</a> and
<a href="https://stackoverflow.com" class="bare">https://stackoverflow.com</a> are my lifesavers in such cases. No embarrassment!</p>
</div>
<div class="paragraph">
<p>During this book, we will work with recursions. So you&#8217;ll get a better feeling for
it.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mix"><a class="anchor" href="#_mix"></a>mix</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>By now, you understand the basics of Elixir. The next step is to create an
application. In the Elixir ecosystem, this is done with the (already installed)
command-line interface (CLI) <code>mix</code>. Let&#8217;s do that for a "Hello world!"
application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix new hello_world
* creating README.md
* creating .formatter.exs
* creating .gitignore
* creating mix.exs
* creating lib
* creating lib/hello_world.ex
* creating test
* creating test/test_helper.exs
* creating test/hello_world_test.exs

Your Mix project was created successfully.
You can use "mix" to compile it, test it, and more:

    cd hello_world
    mix test

Run "mix help" for more commands.</code></pre>
</div>
</div>
<div class="paragraph">
<p>The command ´mix new projectname` creates a new directory with the name <code>projectname</code>
and fills it with a default structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ cd hello_world
$ tree
.
├── README.md
├── lib
│   └── hello_world.ex
├── mix.exs
└── test
    ├── hello_world_test.exs
    └── test_helper.exs

2 directories, 5 files</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Phoenix directory structure will be more involved but has the same core.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mix_tasks"><a class="anchor" href="#_mix_tasks"></a>mix tasks</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>A task is a mechanism to start code with <code>mix</code>. For our "Hello world!"
programme we have to create the directory <code>lib/mix/tasks</code> and create the file
<code>lib/mix/tasks/start.ex</code> with this code:</p>
</div>
<div class="paragraph">
<p>lib/mix/tasks/start.ex</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule Mix.Tasks.Start do
  use Mix.Task

  def run(_) do <i class="conum" data-value="1"></i><b>(1)</b>
    IO.puts "Hello world!"
  end
end</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>run(_)</code> function is the default function which gets called automatically.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we can start the <code>mix start</code> task:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix start
Compiling 1 file (.ex)
Generated hello_world app
Hello world!</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.ex</code> file gets compiled, and the <code>start</code> task gets run. The compile is only
done when needed. If we call <code>mix start</code> a second time no compile is needed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mix start
Hello world!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously <code>mix</code> as a topic is much more complicated. In this section, I just
wanted to show you the very basic idea of <code>mix</code> so that you know where to search
if you want to know what happens if you do a <code>mix server</code> with a Phoenix
application.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mix_format"><a class="anchor" href="#_mix_format"></a>mix format</h2>
<div class="sectionbody">
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>You are going to love <code>mix format</code>. You can call it in the root directory of
your Phoenix application and it will autoformat all your Elixir source code
files.</p>
</div>
<div class="paragraph">
<p>You should use <code>mix format</code> every time you are going to commit code to a
repository.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_else"><a class="anchor" href="#_what_else"></a>What else?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter just deals with the tip of the iceberg. It provides the basic
knowledge that you need to start with the Phoenix Framework. There is a lot more
to learn. But I wouldn&#8217;t worry too much about that right now. You are good to
go for the next chapter of this book. Have fun!</p>
</div>
<div class="sect2">
<h3 id="_elixir_books"><a class="anchor" href="#_elixir_books"></a>Elixir Books</h3>
<div class="paragraph">
<p>If you want to dive more into Elixir than I recommend the following
books:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://pragprog.com/book/cdc-elixir/learn-functional-programming-with-elixir">Learn Functional Programming with Elixir</a> by Ulisses Almeida (<a href="https://twitter.com/ulissesalmeida">@ulissesalmeida</a>)</p>
<div class="paragraph">
<p>In my opinion, the best beginners book for Elixir.</p>
</div>
</li>
<li>
<p>[Programming Elixir 1.6](<a href="https://pragprog.com/book/elixir16/programming-elixir-1-6" class="bare">https://pragprog.com/book/elixir16/programming-elixir-1-6</a>) by Dave Thomas (<a href="https://twitter.com/pragdave">@pragdave</a>)</p>
<div class="paragraph">
<p>Dave - as always - wrote a very book which shines a light into many details.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>Copyright (C) 2020-2020 Stefan Wintermeyer - <a href="https://www.wintermeyer-consulting.de">wintermeyer-consulting.de</a> - Twitter: <a href="https://twitter.com/wintermeyer">@wintermeyer</a></p>
  <p>This webpage was built with <a href="https://antora.org">Antora</a>.</p>
</footer>
<script src="../../antora-assets/js/site.js"></script>
<script async src="../../antora-assets/js/vendor/highlight.js"></script>
  </body>
</html>
